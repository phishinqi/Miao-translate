<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>喵语翻译器</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            flex: 1;
            text-align: center;
            padding: 12px;
            cursor: pointer;
            border-bottom: 2px solid #ddd;
            transition: all 0.3s;
        }
        .tab.active {
            border-bottom: 2px solid #3498db;
            color: #3498db;
        }
        textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .copy-btn {
            background-color: #2ecc71;
            margin-left: 10px;
            padding: 8px 16px;
            font-size: 14px;
        }
        .copy-btn:hover {
            background-color: #27ae60;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 14px;
            color: #7f8c8d;
        }
        .debug-panel {
            margin-top: 30px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        #debug-btn {
            background-color: #e74c3c;
        }
        #debug-btn:hover {
            background-color: #c0392b;
        }
        #debug-info {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            border: 1px solid #e9ecef;
        }

        /* 配置对话框样式 */
        .config-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .config-modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .config-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        .config-close:hover {
            color: #e74c3c;
        }
        .config-section {
            margin-bottom: 25px;
        }
        .config-section h4 {
            margin-bottom: 10px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .config-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            margin-bottom: 10px;
        }
        .config-textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
        }
        .config-buttons {
            text-align: right;
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .config-btn {
            padding: 10px 20px;
            margin-left: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .config-btn-primary {
            background-color: #3498db;
            color: white;
        }
        .config-btn-primary:hover {
            background-color: #2980b9;
        }
        .config-btn-secondary {
            background-color: #95a5a6;
            color: white;
        }
        .config-btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .config-btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .config-btn-danger:hover {
            background-color: #c0392b;
        }
        .theme-selector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .theme-btn {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        .theme-btn:hover {
            opacity: 0.8;
        }
        .theme-btn.active {
            background-color: #e74c3c;
        }

        /* 深色主题下的主题选择器 */
        body.dark-theme .theme-selector {
            background-color: rgba(45, 45, 45, 0.9);
            border: 1px solid #555555;
        }

        /* 深色主题 */
        body.dark-theme {
            background-color: #2c3e50;
            color: #e0e0e0;
        }
        body.dark-theme .container {
            background-color: #34495e;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        body.dark-theme h1 {
            color: #ffffff;
        }
        body.dark-theme .tab {
            border-bottom: 2px solid #555555;
            color: #cccccc;
            background-color: transparent;
        }
        body.dark-theme .tab:hover {
            background-color: #404040;
        }
        body.dark-theme .tab.active {
            border-bottom: 2px solid #4a9eff;
            color: #4a9eff;
            background-color: #333333;
        }
        body.dark-theme textarea {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme textarea:focus {
            border-color: #4a9eff;
            outline: none;
        }
        body.dark-theme textarea::placeholder {
            color: #888888;
        }
        body.dark-theme button {
            background-color: #4a9eff;
            color: #ffffff;
        }
        body.dark-theme button:hover {
            background-color: #357abd;
        }
        body.dark-theme .result {
            background-color: #1e1e1e;
            border-left: 4px solid #4a9eff;
            color: #e0e0e0;
        }
        body.dark-theme .copy-btn {
            background-color: #28a745;
        }
        body.dark-theme .copy-btn:hover {
            background-color: #1e7e34;
        }
        body.dark-theme .footer {
            color: #888888;
        }
        body.dark-theme .debug-panel {
            border-top: 1px solid #555555;
        }
        body.dark-theme textarea {
            background-color: #2c3e50;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme textarea:focus {
            border-color: #3498db;
            outline: none;
        }
        body.dark-theme textarea::placeholder {
            color: #888888;
        }
        body.dark-theme .result {
            background-color: #2c3e50;
            border-left: 4px solid #3498db;
        }
        body.dark-theme #debug-info {
            background-color: #2c3e50;
            color: #e0e0e0;
            border: 1px solid #555555;
        }

        /* 深色主题下的配置对话框 */
        body.dark-theme .config-modal-content {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }
        body.dark-theme .config-section h4 {
            color: #ffffff;
            border-bottom: 2px solid #4a9eff;
        }
        body.dark-theme .config-input,
        body.dark-theme .config-textarea {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme .config-input:focus,
        body.dark-theme .config-textarea:focus {
            border-color: #4a9eff;
            outline: none;
        }
        body.dark-theme .config-buttons {
            border-top: 1px solid #555555;
        }

        /* 粉色主题 */
        body.pink-theme {
            background-color: #fdf2f8;
            color: #831843;
        }
        body.pink-theme .container {
            background-color: #fce7f3;
            box-shadow: 0 2px 10px rgba(219, 39, 119, 0.1);
        }
        body.pink-theme h1 {
            color: #be185d;
        }
        body.pink-theme .tab.active {
            border-bottom: 2px solid #ec4899;
            color: #ec4899;
        }
        body.pink-theme button {
            background-color: #ec4899;
        }
        body.pink-theme button:hover {
            background-color: #be185d;
        }
        body.pink-theme .result {
            background-color: #fdf2f8;
            border-left: 4px solid #ec4899;
        }

        /* 绿色主题 */
        body.green-theme {
            background-color: #f0fdf4;
            color: #14532d;
        }
        body.green-theme .container {
            background-color: #dcfce7;
            box-shadow: 0 2px 10px rgba(34, 197, 94, 0.1);
        }
        body.green-theme h1 {
            color: #15803d;
        }
        body.green-theme .tab.active {
            border-bottom: 2px solid #22c55e;
            color: #22c55e;
        }
        body.green-theme button {
            background-color: #22c55e;
        }
        body.green-theme button:hover {
            background-color: #15803d;
        }
        body.green-theme .result {
            background-color: #f0fdf4;
            border-left: 4px solid #22c55e;
        }
    </style>
</head>
<body>
    <div class="theme-selector">
        <button class="theme-btn active" data-theme="default">默认</button>
        <button class="theme-btn" data-theme="dark">深色</button>
        <button class="theme-btn" data-theme="pink">粉色</button>
        <button class="theme-btn" data-theme="green">绿色</button>
        <button class="theme-btn" id="config-btn-header" style="background-color: #f39c12;">⚙️</button>
    </div>

    <div class="container">
        <h1>喵语翻译器</h1>

        <div class="tabs">
            <div class="tab active" id="encrypt-tab">加密</div>
            <div class="tab" id="decrypt-tab">解密</div>
        </div>
        
        <div id="encrypt-panel">
            <textarea id="encrypt-input" placeholder="请输入要加密的文本..."></textarea>
            <button id="encrypt-btn">加密</button>

            <div class="result" id="encrypt-result" style="display: none;">
                <h3>加密结果：</h3>
                <p id="encrypt-output"></p>
                <button id="copy-encrypt" class="copy-btn">复制结果</button>
            </div>
        </div>

        <div id="decrypt-panel" style="display: none;">
            <textarea id="decrypt-input" placeholder="请输入要解密的文本..."></textarea>
            <button id="decrypt-btn">解密</button>

            <div class="result" id="decrypt-result" style="display: none;">
                <h3>解密结果：</h3>
                <p id="decrypt-output"></p>
                <button id="copy-decrypt" class="copy-btn">复制结果</button>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>喵语翻译器 &copy; 2025</p>
    </div>

    <!-- 配置对话框 -->
    <div id="config-modal" class="config-modal">
        <div class="config-modal-content">
            <span class="config-close">&times;</span>
            <h2>配置参数</h2>

            <div class="config-section">
                <h4>加密参数</h4>
                <label>版本号 (VERSION):</label>
                <input type="text" id="config-version" class="config-input" placeholder="例如: MiaoV0721">

                <label>密钥 (KEY):</label>
                <input type="text" id="config-key" class="config-input" placeholder="例如: 2hY8u5Pq3zRv7xW4jN0c1fT9eD6aXsB0">

                <label>盐值 (SALT):</label>
                <input type="text" id="config-salt" class="config-input" placeholder="例如: K7mLp2oQ9nRz8sV4tC1uJ6yF3dH5gXbE">
            </div>

            <div class="config-section">
                <h4>喵语词汇</h4>
                <label>喵语短语 (每行一个):</label>
                <textarea id="config-phrases" class="config-textarea" placeholder="喵&#10;喵喵&#10;喵~&#10;喵呜&#10;喵嗷&#10;喵喵喵"></textarea>
            </div>

            <div class="config-section">
                <h4>标点符号</h4>
                <label>标点符号 (每行一个):</label>
                <textarea id="config-punctuations" class="config-textarea" placeholder="，&#10;。&#10;！&#10;？&#10;~&#10;..."></textarea>
            </div>

            <div class="config-buttons">
                <button class="config-btn config-btn-danger" id="config-reset">重置为默认</button>
                <button class="config-btn config-btn-secondary" id="config-cancel">取消</button>
                <button class="config-btn config-btn-primary" id="config-save">保存配置</button>
            </div>
        </div>
    </div>

    <script>
        // 零宽字符集
        const ZERO_WIDTH_CHARS = [
            '\u200b',
            '\u200c',
            '\u200d',
            '\u2060',
            '\u200e',
            '\u200f',
            '\ufeff',
        ];

        // 默认配置
        const DEFAULT_CONFIG = {
            VERSION: "MiaoV0721",
            KEY: "2hY8u5Pq3zRv7xW4jN0c1fT9eD6aXsB0",
            SALT: "K7mLp2oQ9nRz8sV4tC1uJ6yF3dH5gXbE",
            PHRASES: ["喵", "喵喵", "喵~", "喵呜", "喵嗷", "喵喵喵"],
            PUNCTUATIONS: ["，", "。", "！", "？", "~", "..."]
        };

        // 当前配置（可以被用户修改）
        let CONFIG = { ...DEFAULT_CONFIG };

        // 为了向后兼容，保留原有的变量名
        let KEY = CONFIG.KEY;
        let SALT = CONFIG.SALT;
        let VERSION = CONFIG.VERSION;
        let PHRASES = [...CONFIG.PHRASES];
        let PUNCTUATIONS = [...CONFIG.PUNCTUATIONS];

        // 配置管理函数
        function loadConfig() {
            const savedConfig = localStorage.getItem('miao-config');
            if (savedConfig) {
                try {
                    const parsed = JSON.parse(savedConfig);
                    CONFIG = { ...DEFAULT_CONFIG, ...parsed };
                    updateVariables();
                } catch (e) {
                    console.warn('配置加载失败，使用默认配置');
                }
            }
        }

        function saveConfig() {
            localStorage.setItem('miao-config', JSON.stringify(CONFIG));
            updateVariables();
        }

        function updateVariables() {
            KEY = CONFIG.KEY;
            SALT = CONFIG.SALT;
            VERSION = CONFIG.VERSION;
            PHRASES = [...CONFIG.PHRASES];
            PUNCTUATIONS = [...CONFIG.PUNCTUATIONS];
        }

        function resetConfig() {
            CONFIG = { ...DEFAULT_CONFIG };
            updateVariables();
            updateConfigUI();
        }

        function updateConfigUI() {
            document.getElementById('config-version').value = CONFIG.VERSION;
            document.getElementById('config-key').value = CONFIG.KEY;
            document.getElementById('config-salt').value = CONFIG.SALT;
            document.getElementById('config-phrases').value = CONFIG.PHRASES.join('\n');
            document.getElementById('config-punctuations').value = CONFIG.PUNCTUATIONS.join('\n');
        }

        function getConfigFromUI() {
            const phrases = document.getElementById('config-phrases').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            const punctuations = document.getElementById('config-punctuations').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            return {
                VERSION: document.getElementById('config-version').value.trim() || DEFAULT_CONFIG.VERSION,
                KEY: document.getElementById('config-key').value.trim() || DEFAULT_CONFIG.KEY,
                SALT: document.getElementById('config-salt').value.trim() || DEFAULT_CONFIG.SALT,
                PHRASES: phrases.length > 0 ? phrases : DEFAULT_CONFIG.PHRASES,
                PUNCTUATIONS: punctuations.length > 0 ? punctuations : DEFAULT_CONFIG.PUNCTUATIONS
            };
        }

        // 创建Base64字符到零宽字符组合的映射
        function createBase64ToZeroWidthMap() {
            const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            const mapping = {};

            // 使用固定长度的零宽字符组合，确保一致性
            const COMBO_LENGTH = 6; // 固定长度

            // 为每个Base64字符创建唯一且固定长度的零宽字符组合
            for (let i = 0; i < base64Chars.length; i++) {
                const char = base64Chars[i];

                // 使用字符的实际索引位置（而不是字符本身）生成确定性的组合
                let zeroWidthCombo = "";
                for (let j = 0; j < COMBO_LENGTH; j++) {
                    // 使用更简单和确定性的算法
                    const keyIndex = (i + j) % KEY.length;
                    const keyChar = KEY.charCodeAt(keyIndex);
                    const saltIndex = (i * 2 + j) % SALT.length;
                    const saltChar = SALT.charCodeAt(saltIndex);

                    // 确保每个字符都有唯一的映射
                    const uniqueValue = (i * 13 + j * 17 + keyChar + saltChar) % ZERO_WIDTH_CHARS.length;
                    zeroWidthCombo += ZERO_WIDTH_CHARS[uniqueValue];
                }

                mapping[char] = zeroWidthCombo;
            }

            // 验证映射的唯一性
            const usedCombos = new Set();
            for (const [char, combo] of Object.entries(mapping)) {
                if (usedCombos.has(combo)) {
                    console.error(`映射冲突: 字符 ${char} 的组合已被使用`);
                }
                usedCombos.add(combo);
            }

            return mapping;
        }

        // 混淆函数
        function starResonanceScramble(str, key, salt) {
            try {
                // 1. 将输入字符串与盐值组合
                const saltedInput = str + ":" + salt;
                
                // 2. 使用密钥的特征值进行额外处理
                let result = '';
                const keyChars = Array.from(key);
                const keySum = keyChars.reduce((sum, char) => sum + char.charCodeAt(0), 0);
                
                for (let i = 0; i < saltedInput.length; i++) {
                    const charCode = saltedInput.charCodeAt(i);
                    const keyChar = key.charCodeAt(i % key.length);
                    const xorResult = charCode ^ keyChar;
                    
                    // 根据位置和密钥特征值进行偏移
                    const offset = (i % 3 === 0) ? (keySum % 7) : ((i % 3 === 1) ? -(keySum % 5) : (keySum % 3));
                    const finalCharCode = (xorResult + offset + 65536) % 65536; // 确保在有效Unicode范围内
                    
                    result += String.fromCharCode(finalCharCode);
                }
                
                // 3. 添加版本标记
                return VERSION + ":" + result;
            } catch (e) {
                console.error("混淆过程中出错:", e);
                throw e;
            }
        }

        // 解混淆函数
        function starResonanceUnscramble(scrambled, key, salt) {
            try {
                // 1. 验证并移除版本标记
                if (!scrambled.startsWith(VERSION + ":")) {
                    console.error("版本标记不匹配:", scrambled.substring(0, 20));
                    throw new Error("无效的加密格式或版本不匹配");
                }
                
                const dataWithoutVersion = scrambled.substring(VERSION.length + 1);
                
                // 2. 反向应用额外处理
                let result = '';
                const keyChars = Array.from(key);
                const keySum = keyChars.reduce((sum, char) => sum + char.charCodeAt(0), 0);
                
                for (let i = 0; i < dataWithoutVersion.length; i++) {
                    // 反向应用额外处理
                    const charCode = dataWithoutVersion.charCodeAt(i);
                    const offset = (i % 3 === 0) ? (keySum % 7) : ((i % 3 === 1) ? -(keySum % 5) : (keySum % 3));
                    const unshiftedCharCode = (charCode - offset + 65536) % 65536; // 确保在有效Unicode范围内
                    
                    // XOR解密
                    const keyChar = key.charCodeAt(i % key.length);
                    const originalCharCode = unshiftedCharCode ^ keyChar;
                    
                    result += String.fromCharCode(originalCharCode);
                }
                
                // 3. 移除盐值 - 改进版本，更好地处理边界情况
                const saltMarker = ":" + salt;
                const saltIndex = result.lastIndexOf(saltMarker);

                if (saltIndex === -1) {
                    console.error("无法找到完整的盐值标记，尝试其他方法");
                    console.log("解混淆结果:", result);
                    console.log("期望的盐值标记:", saltMarker);

                    // 尝试查找任何冒号分隔符
                    const lastColonIndex = result.lastIndexOf(":");
                    if (lastColonIndex !== -1) {
                        const possibleSalt = result.substring(lastColonIndex + 1);
                        console.log("找到的可能盐值:", possibleSalt);

                        // 检查是否是预期的盐值
                        if (possibleSalt === salt) {
                            console.log("找到匹配的盐值，使用冒号分隔点");
                            return result.substring(0, lastColonIndex);
                        } else {
                            console.log("盐值不匹配，尝试直接返回结果");
                            // 如果盐值不匹配，可能是解混淆过程中的字符编码问题
                            // 尝试返回去掉最后部分的结果
                            return result.substring(0, lastColonIndex);
                        }
                    }

                    // 最后的备用方案：检查结果是否已经是有效的原始消息
                    console.log("无法找到盐值分隔符，检查结果是否有效");
                    if (result.length > salt.length + 1) {
                        // 尝试去掉可能的盐值后缀
                        const withoutSuffix = result.substring(0, result.length - salt.length - 1);
                        console.log("尝试去掉后缀:", withoutSuffix);
                        return withoutSuffix;
                    }

                    throw new Error("解密失败：无效的数据格式");
                }

                return result.substring(0, saltIndex);
            } catch (e) {
                console.error("解混淆过程中出错:", e);
                throw e;
            }
        }

        // 喵加密消息函数 - 简化版本，增加调试信息
        function encryptMessage(message) {
            try {
                console.log(`开始加密消息: "${message}"`);

                // 1. 使用混淆函数处理原始消息
                const scrambledMessage = starResonanceScramble(message, KEY, SALT);
                console.log(`混淆后消息长度: ${scrambledMessage.length}`);

                // 2. 创建Base64到零宽字符的映射
                const b64ToZwMap = createBase64ToZeroWidthMap();

                // 3. 将混淆后的消息转为Base64
                const base64Message = btoa(unescape(encodeURIComponent(scrambledMessage)));
                console.log(`Base64消息: "${base64Message}" (长度: ${base64Message.length})`);

                // 4. 将Base64转为零宽字符
                let zeroWidthMessage = "";
                for (let i = 0; i < base64Message.length; i++) {
                    const b64Char = base64Message[i];
                    const zwCombo = b64ToZwMap[b64Char];
                    if (!zwCombo) {
                        console.error(`Base64字符 '${b64Char}' 没有对应的零宽字符映射`);
                        throw new Error(`映射错误: 字符 '${b64Char}' 未找到映射`);
                    }
                    zeroWidthMessage += zwCombo;
                }
                console.log(`零宽字符消息长度: ${zeroWidthMessage.length}`);

                // 5. 生成简化的喵语文本
                const result = generateSimpleMeowText(zeroWidthMessage);
                console.log(`最终加密结果长度: ${result.length}`);
                return result;
            } catch (e) {
                console.error("加密过程中出错:", e);
                throw new Error(`加密失败: ${e.message}`);
            }
        }

        // 生成紧凑的喵语文本
        function generateSimpleMeowText(zeroWidthMessage) {
            // 确保零宽字符按完整的组合进行分割
            const COMBO_LENGTH = 6;
            const completeComboCount = Math.floor(zeroWidthMessage.length / COMBO_LENGTH);
            const usableLength = completeComboCount * COMBO_LENGTH;

            console.log(`零宽字符总长度: ${zeroWidthMessage.length}, 完整组合数: ${completeComboCount}, 可用长度: ${usableLength}`);

            // 使用确定性随机数生成器，基于消息内容
            let seed = zeroWidthMessage.length;
            const getNextRandom = () => {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            };

            // 紧凑模式：最少的喵语词汇，最大化零宽字符密度
            let result = "";
            let zwIndex = 0;

            // 大幅减少喵语词的数量，每10-15个组合才用一个词
            const wordsNeeded = Math.max(2, Math.ceil(completeComboCount / 12)); // 每12个组合一个词

            for (let i = 0; i < wordsNeeded; i++) {
                // 只在开头和中间添加少量喵语词
                if (i === 0 || i === Math.floor(wordsNeeded / 2) || i === wordsNeeded - 1) {
                    // 使用最短的喵语词
                    const shortPhrases = ["喵", "喵~"];
                    const phrase = shortPhrases[Math.floor(getNextRandom() * shortPhrases.length)];
                    result += phrase;
                }

                // 计算这个词后面要添加多少个零宽字符组合
                const remainingCombos = completeComboCount - zwIndex;
                const remainingWords = wordsNeeded - i;
                const combosForThisWord = Math.ceil(remainingCombos / remainingWords);

                // 添加零宽字符组合
                for (let j = 0; j < combosForThisWord && zwIndex < completeComboCount; j++) {
                    const startPos = zwIndex * COMBO_LENGTH;
                    const endPos = (zwIndex + 1) * COMBO_LENGTH;
                    result += zeroWidthMessage.substring(startPos, endPos);
                    zwIndex++;
                }

                // 减少标点符号的使用，只在必要时添加
                if (i === Math.floor(wordsNeeded / 2) && wordsNeeded > 2) {
                    result += "，"; // 只在中间添加一个逗号
                }
            }

            // 确保所有零宽字符都被包含
            if (zwIndex < completeComboCount) {
                console.warn(`还有 ${completeComboCount - zwIndex} 个组合未处理，直接添加`);
                const remainingStart = zwIndex * COMBO_LENGTH;
                const remainingEnd = completeComboCount * COMBO_LENGTH;
                result += zeroWidthMessage.substring(remainingStart, remainingEnd);
            }

            // 简化结尾，只添加一个句号
            result += "。";

            console.log(`生成的喵语文本长度: ${result.length}, 处理的零宽字符组合: ${zwIndex}/${completeComboCount}`);

            return result;
        }

        // 优化后的解密消息函数，提高解密可靠性 - 修复版本，增加调试信息
        function decryptMessage(encryptedMessage) {
            try {
                console.log(`开始解密消息，长度: ${encryptedMessage.length}`);

                // 1. 创建Base64到零宽字符的映射
                const b64ToZwMap = createBase64ToZeroWidthMap();

                // 创建反向映射
                const zwToB64Map = {};
                for (const [key, value] of Object.entries(b64ToZwMap)) {
                    zwToB64Map[value] = key;
                }
                console.log(`创建了 ${Object.keys(zwToB64Map).length} 个反向映射`);

                // 2. 提取所有零宽字符
                const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                const zeroWidthMatches = encryptedMessage.match(zeroWidthCharsRegex) || [];
                const zeroWidthOnly = zeroWidthMatches.join('');

                console.log(`提取到 ${zeroWidthOnly.length} 个零宽字符`);
                console.log(`零宽字符预览: ${Array.from(zeroWidthOnly.substring(0, 12)).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join(' ')}`);

                // 3. 将零宽字符转回Base64 - 使用固定长度分组
                let base64Message = "";
                const COMBO_LENGTH = 6; // 与加密时保持一致

                // 按固定长度分组处理 - 改进版本，增加错误处理
                let unmappedCount = 0;
                for (let i = 0; i < zeroWidthOnly.length; i += COMBO_LENGTH) {
                    if (i + COMBO_LENGTH <= zeroWidthOnly.length) {
                        const zwCombo = zeroWidthOnly.substring(i, i + COMBO_LENGTH);

                        if (zwCombo in zwToB64Map) {
                            base64Message += zwToB64Map[zwCombo];
                        } else {
                            unmappedCount++;
                            console.warn(`无法找到零宽字符组合的映射 (位置 ${i}): ${Array.from(zwCombo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('')}`);

                            // 尝试查找最相似的映射
                            let bestMatch = null;
                            let minDifference = Infinity;

                            for (const [mappedCombo, b64Char] of Object.entries(zwToB64Map)) {
                                let difference = 0;
                                for (let j = 0; j < COMBO_LENGTH; j++) {
                                    if (zwCombo[j] !== mappedCombo[j]) {
                                        difference++;
                                    }
                                }
                                if (difference < minDifference) {
                                    minDifference = difference;
                                    bestMatch = b64Char;
                                }
                            }

                            if (bestMatch && minDifference <= 2) {
                                console.log(`使用最相似的映射: ${bestMatch} (差异: ${minDifference})`);
                                base64Message += bestMatch;
                            } else {
                                console.error(`无法找到合适的替代映射，跳过此组合`);
                                // 不添加任何字符，这可能导致Base64不完整
                            }
                        }
                    } else {
                        // 处理不完整的最后一组
                        console.warn(`剩余零宽字符长度不足: ${zeroWidthOnly.length - i}`);
                        break;
                    }
                }

                console.log(`未映射的组合数量: ${unmappedCount}`);

                console.log(`解析出的Base64字符串长度: ${base64Message.length}`);

                // 4. 修复Base64字符串的填充
                base64Message = fixBase64Padding(base64Message);

                // 5. 检查Base64格式是否有效
                console.log(`最终Base64字符串: "${base64Message}"`);
                if (!isValidBase64(base64Message)) {
                    console.error("解析出的Base64字符串无效:", base64Message);
                    console.log("尝试修复Base64字符串...");

                    // 尝试修复常见的Base64问题
                    let fixedBase64 = base64Message;

                    // 移除无效字符
                    fixedBase64 = fixedBase64.replace(/[^A-Za-z0-9+/=]/g, '');

                    // 重新修复填充
                    fixedBase64 = fixBase64Padding(fixedBase64);

                    console.log(`修复后的Base64: "${fixedBase64}"`);

                    if (isValidBase64(fixedBase64)) {
                        console.log("Base64修复成功");
                        base64Message = fixedBase64;
                    } else {
                        throw new Error("解密失败：无效的Base64格式，修复失败");
                    }
                }

                // 6. 将Base64解码回混淆后的消息
                let scrambledMessage;
                try {
                    const decodedData = atob(base64Message);
                    scrambledMessage = decodeURIComponent(escape(decodedData));
                } catch (e) {
                    console.warn("标准解码方法失败，尝试备用方法:", e);

                    // 备用解码方法，处理非ASCII字符
                    try {
                        const bytes = [];
                        const decodedData = atob(base64Message);
                        for (let i = 0; i < decodedData.length; i++) {
                            bytes.push(decodedData.charCodeAt(i));
                        }
                        const decoder = new TextDecoder('utf-8');
                        scrambledMessage = decoder.decode(new Uint8Array(bytes));
                    } catch (backupError) {
                        console.error("备用解码方法也失败:", backupError);
                        throw new Error(`解密失败: 无法解码Base64数据`);
                    }
                }

                // 7. 使用解混淆函数还原原始消息
                return starResonanceUnscramble(scrambledMessage, KEY, SALT);
            } catch (e) {
                console.error("解密错误详情:", e);
                throw new Error(`解密失败: ${e.message}`);
            }
        }

        // 修复Base64填充的辅助函数
        function fixBase64Padding(str) {
            // 移除所有现有的填充字符
            str = str.replace(/=+$/, '');

            // 根据长度添加正确的填充
            const remainder = str.length % 4;
            if (remainder === 2) {
                str += '==';
            } else if (remainder === 3) {
                str += '=';
            }
            // remainder === 0 或 1 时不需要填充（1是无效的，但我们先尝试处理）

            return str;
        }

        // 添加辅助函数检查Base64有效性 - 改进版本
        function isValidBase64(str) {
            try {
                // 检查基本格式
                if (!str) {
                    return false;
                }

                // 检查字符是否都是有效的Base64字符
                const validChars = /^[A-Za-z0-9+/=]+$/;
                if (!validChars.test(str)) {
                    return false;
                }

                // 检查长度是否为4的倍数
                if (str.length % 4 !== 0) {
                    return false;
                }

                // 检查填充字符的位置是否正确
                const paddingMatch = str.match(/=*$/);
                if (paddingMatch) {
                    const paddingLength = paddingMatch[0].length;
                    if (paddingLength > 2) {
                        return false; // 填充字符不能超过2个
                    }

                    // 检查填充前的字符是否有效
                    const withoutPadding = str.substring(0, str.length - paddingLength);
                    if (paddingLength > 0 && withoutPadding.length % 4 !== (4 - paddingLength) % 4) {
                        return false;
                    }
                }

                // 尝试解码
                atob(str);
                return true;
            } catch (e) {
                return false;
            }
        }

        // 主题切换功能
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // 如果是配置按钮，不处理主题切换
                if (this.id === 'config-btn-header') {
                    return;
                }

                const theme = this.getAttribute('data-theme');

                // 移除所有主题类
                document.body.classList.remove('dark-theme', 'pink-theme', 'green-theme');

                // 添加新主题类
                if (theme !== 'default') {
                    document.body.classList.add(theme + '-theme');
                }

                // 更新按钮状态（排除配置按钮）
                document.querySelectorAll('.theme-btn').forEach(b => {
                    if (b.id !== 'config-btn-header') {
                        b.classList.remove('active');
                    }
                });
                this.classList.add('active');

                // 保存主题设置
                localStorage.setItem('theme', theme);
            });
        });

        // 加载保存的主题
        const savedTheme = localStorage.getItem('theme') || 'default';
        if (savedTheme !== 'default') {
            document.body.classList.add(savedTheme + '-theme');
        }

        // 设置主题按钮状态（排除配置按钮）
        document.querySelectorAll('.theme-btn').forEach(b => {
            if (b.id !== 'config-btn-header') {
                if (b.getAttribute('data-theme') === savedTheme) {
                    b.classList.add('active');
                } else {
                    b.classList.remove('active');
                }
            }
        });

        // 加载保存的配置
        loadConfig();

        // 配置对话框事件监听器
        const configModal = document.getElementById('config-modal');
        const configBtnHeader = document.getElementById('config-btn-header');
        const configClose = document.querySelector('.config-close');
        const configSave = document.getElementById('config-save');
        const configCancel = document.getElementById('config-cancel');
        const configReset = document.getElementById('config-reset');

        // 打开配置对话框
        configBtnHeader.addEventListener('click', function() {
            updateConfigUI();
            configModal.style.display = 'block';
        });

        // 关闭配置对话框
        configClose.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        configCancel.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        // 点击对话框外部关闭
        window.addEventListener('click', function(event) {
            if (event.target === configModal) {
                configModal.style.display = 'none';
            }
        });

        // 保存配置
        configSave.addEventListener('click', function() {
            CONFIG = getConfigFromUI();
            saveConfig();
            configModal.style.display = 'none';
            alert('配置已保存！');
        });

        // 重置配置
        configReset.addEventListener('click', function() {
            if (confirm('确定要重置为默认配置吗？这将清除所有自定义设置。')) {
                resetConfig();
                alert('配置已重置为默认值！');
            }
        });

        // 切换标签页
        document.getElementById('encrypt-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('decrypt-tab').classList.remove('active');
            document.getElementById('encrypt-panel').style.display = 'block';
            document.getElementById('decrypt-panel').style.display = 'none';
        });

        document.getElementById('decrypt-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('encrypt-tab').classList.remove('active');
            document.getElementById('decrypt-panel').style.display = 'block';
            document.getElementById('encrypt-panel').style.display = 'none';
        });

        // 加密按钮点击事件
        document.getElementById('encrypt-btn').addEventListener('click', function() {
            const input = document.getElementById('encrypt-input').value;
            if (!input) {
                alert('请输入要加密的文本');
                return;
            }

            try {
                const encrypted = encryptMessage(input);
                document.getElementById('encrypt-output').textContent = encrypted;
                document.getElementById('encrypt-result').style.display = 'block';
            } catch (e) {
                alert(`加密失败: ${e.message}`);
            }
        });

        // 解密按钮点击事件
        document.getElementById('decrypt-btn').addEventListener('click', function() {
            const input = document.getElementById('decrypt-input').value;
            if (!input) {
                alert('请输入要解密的文本');
                return;
            }
            
            try {
                const decrypted = decryptMessage(input);
                document.getElementById('decrypt-output').textContent = decrypted;
                document.getElementById('decrypt-result').style.display = 'block';
            } catch (e) {
                alert(`解密失败: ${e.message}`);
            }
        });

        // 复制加密结果
        document.getElementById('copy-encrypt').addEventListener('click', function() {
            const text = document.getElementById('encrypt-output').textContent;
            navigator.clipboard.writeText(text).then(function() {
                alert('已复制到剪贴板');
            }, function() {
                alert('复制失败，请手动复制');
            });
        });

        // 复制解密结果
        document.getElementById('copy-decrypt').addEventListener('click', function() {
            const text = document.getElementById('decrypt-output').textContent;
            navigator.clipboard.writeText(text).then(function() {
                alert('已复制到剪贴板');
            }, function() {
                alert('复制失败，请手动复制');
            });
        });

        // 添加调试按钮和面板
        document.querySelector('.container').insertAdjacentHTML('beforeend', `
            <div class="debug-panel">
                <h3>调试工具</h3>
                <button id="debug-btn">显示调试信息</button>
                <div id="debug-info"></div>
            </div>
        `);

        // 调试按钮点击事件
        document.getElementById('debug-btn').addEventListener('click', async function() {
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo.style.display === 'none') {
                // 收集调试信息
                let info = "";
                
                // 1. 显示关键参数
                info += "=== 关键参数 ===\n";
                info += `VERSION: ${VERSION}\n`;
                info += `KEY: ${KEY}\n`;
                info += `SALT: ${SALT}\n\n`;
                
                // 2. 测试零宽字符映射一致性
                info += "=== 零宽字符映射一致性测试 ===\n";
                const testChar = 'A';
                const b64ToZwMap = createBase64ToZeroWidthMap();
                const zwEncoded = b64ToZwMap[testChar];
                
                // 创建反向映射
                const zwToB64Map = {};
                for (const [key, value] of Object.entries(b64ToZwMap)) {
                    zwToB64Map[value] = key;
                }
                
                const b64Decoded = zwToB64Map[zwEncoded];
                
                info += `测试字符: '${testChar}'\n`;
                info += `编码为零宽字符: [${Array.from(zwEncoded).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join(', ')}]\n`;
                info += `解码回Base64: '${b64Decoded}'\n`;
                info += `映射一致性: ${testChar === b64Decoded ? '✓ 正常' : '✗ 错误'}\n\n`;
                
                // 3. 测试加密解密一致性
                info += "=== 加密解密一致性测试 ===\n";
                const testMessage = "测试消息123";

                try {
                    // 直接测试混淆函数
                    const scrambled = starResonanceScramble(testMessage, KEY, SALT);
                    info += `原始消息: "${testMessage}" (长度: ${testMessage.length})\n`;
                    info += `混淆后长度: ${scrambled.length}\n`;
                    info += `混淆后预览: "${scrambled.substring(0, 30)}${scrambled.length > 30 ? '...' : ''}"\n`;

                    // 分析混淆后的字符分布
                    const charTypes = {
                        ascii: 0,
                        chinese: 0,
                        special: 0,
                        control: 0
                    };

                    for (let i = 0; i < scrambled.length; i++) {
                        const code = scrambled.charCodeAt(i);
                        if (code < 128) {
                            charTypes.ascii++;
                        } else if (code >= 0x4e00 && code <= 0x9fff) {
                            charTypes.chinese++;
                        } else if (code < 32 || code === 127) {
                            charTypes.control++;
                        } else {
                            charTypes.special++;
                        }
                    }

                    info += `字符分布 - ASCII: ${charTypes.ascii}, 中文: ${charTypes.chinese}, 特殊: ${charTypes.special}, 控制: ${charTypes.control}\n`;

                    try {
                        const unscrambled = starResonanceUnscramble(scrambled, KEY, SALT);
                        info += `解混淆后: "${unscrambled}" (长度: ${unscrambled.length})\n`;
                        info += `一致性: ${testMessage === unscrambled ? '✓ 正常' : '✗ 错误'}\n`;

                        if (testMessage !== unscrambled) {
                            info += `差异分析: `;
                            for (let i = 0; i < Math.max(testMessage.length, unscrambled.length); i++) {
                                if (testMessage[i] !== unscrambled[i]) {
                                    info += `位置${i}: "${testMessage[i] || 'null'}" vs "${unscrambled[i] || 'null'}" `;
                                }
                            }
                            info += `\n`;
                        }
                        info += `\n`;
                    } catch (e) {
                        info += `解混淆失败: ${e.message}\n`;
                        info += `错误类型: ${e.constructor.name}\n\n`;
                    }

                    // 4. 测试完整的加密解密流程（包含详细调试）
                    info += "=== 完整加密解密流程测试 ===\n";

                    // 加密消息
                    const startTime = performance.now();
                    const encrypted1 = encryptMessage(testMessage);
                    const encryptTime = performance.now() - startTime;

                    info += `加密耗时: ${encryptTime.toFixed(2)}ms\n`;
                    info += `加密结果长度: ${encrypted1.length}\n`;
                    info += `压缩比: ${(encrypted1.length / testMessage.length).toFixed(2)}:1\n`;
                    info += `加密结果预览: "${encrypted1.substring(0, 50)}${encrypted1.length > 50 ? '...' : ''}"\n`;

                    // 分析零宽字符
                    const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                    const zeroWidthMatches = encrypted1.match(zeroWidthCharsRegex) || [];
                    const visibleChars = encrypted1.replace(zeroWidthCharsRegex, '');

                    info += `零宽字符数量: ${zeroWidthMatches.length}\n`;
                    info += `可见字符数量: ${visibleChars.length}\n`;
                    info += `零宽字符占比: ${(zeroWidthMatches.length / encrypted1.length * 100).toFixed(1)}%\n`;
                    info += `零宽字符长度是否为6的倍数: ${zeroWidthMatches.length % 6 === 0 ? '✓ 是' : '✗ 否'}\n`;

                    // 分析零宽字符类型分布
                    const zwTypeCount = {};
                    zeroWidthMatches.forEach(char => {
                        const code = '\\u' + char.charCodeAt(0).toString(16).padStart(4, '0');
                        zwTypeCount[code] = (zwTypeCount[code] || 0) + 1;
                    });
                    info += `零宽字符类型分布: ${Object.entries(zwTypeCount).map(([type, count]) => `${type}:${count}`).join(', ')}\n`;

                    // 详细调试过程
                    try {
                        // 测试Base64重构过程
                        const b64ToZwMap = createBase64ToZeroWidthMap();
                        const zwToB64Map = {};
                        for (const [key, value] of Object.entries(b64ToZwMap)) {
                            zwToB64Map[value] = key;
                        }

                        const zeroWidthOnly = zeroWidthMatches.join('');
                        info += `提取的零宽字符长度: ${zeroWidthOnly.length}\n`;

                        let base64Reconstructed = "";
                        let unmappedCount = 0;
                        for (let i = 0; i < zeroWidthOnly.length; i += 6) {
                            if (i + 6 <= zeroWidthOnly.length) {
                                const combo = zeroWidthOnly.substring(i, i + 6);
                                if (combo in zwToB64Map) {
                                    base64Reconstructed += zwToB64Map[combo];
                                } else {
                                    unmappedCount++;
                                }
                            }
                        }

                        info += `重构的Base64长度: ${base64Reconstructed.length}\n`;
                        info += `未映射的组合数: ${unmappedCount}\n`;
                        info += `Base64有效性: ${isValidBase64(base64Reconstructed) ? '✓ 有效' : '✗ 无效'}\n`;

                        // 解密过程
                        info += "--- 解密过程 ---\n";
                        const decryptStartTime = performance.now();
                        const decrypted1 = decryptMessage(encrypted1);
                        const decryptTime = performance.now() - decryptStartTime;

                        info += `解密耗时: ${decryptTime.toFixed(2)}ms\n`;
                        info += `解密结果: "${decrypted1}"\n`;
                        info += `解密结果长度: ${decrypted1.length}\n`;
                        info += `解密一致性: ${testMessage === decrypted1 ? '✓ 正常' : '✗ 错误'}\n`;
                        info += `总耗时: ${(encryptTime + decryptTime).toFixed(2)}ms\n`;

                        if (testMessage !== decrypted1) {
                            info += `长度对比: 原始${testMessage.length} vs 解密${decrypted1.length}\n`;
                            info += `字符对比: `;
                            for (let i = 0; i < Math.max(testMessage.length, decrypted1.length); i++) {
                                if (testMessage[i] !== decrypted1[i]) {
                                    info += `[${i}]"${testMessage[i] || '∅'}"≠"${decrypted1[i] || '∅'}" `;
                                }
                            }
                            info += `\n`;
                        }

                    } catch (e) {
                        info += `解密失败: ${e.message}\n`;
                    }
                } catch (e) {
                    info += `测试过程出错: ${e.message}\n`;
                }
                
                // 显示调试信息
                debugInfo.textContent = info;
                debugInfo.style.display = 'block';
                this.textContent = '隐藏调试信息';
            } else {
                debugInfo.style.display = 'none';
                this.textContent = '显示调试信息';
            }
        });
    </script>
</body>
</html>