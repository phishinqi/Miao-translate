<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>喵语翻译器</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            flex: 1;
            text-align: center;
            padding: 12px;
            cursor: pointer;
            border-bottom: 2px solid #ddd;
            transition: all 0.3s;
        }
        .tab.active {
            border-bottom: 2px solid #3498db;
            color: #3498db;
        }
        textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
        }
        .char-counter {
            font-size: 12px;
            color: #666;
            text-align: right;
            margin-bottom: 10px;
        }
        .char-counter.warning {
            color: #e67e22;
            font-weight: bold;
        }
        .char-counter.danger {
            color: #e74c3c;
            font-weight: bold;
        }
        .length-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            display: none;
        }
        .result-container {
            position: relative;
        }
        .result-preview {
            max-height: 200px;
            overflow-y: auto;
            word-break: break-all;
            white-space: pre-wrap;
        }
        .result-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .result-stats {
            font-size: 12px;
            color: #666;
            flex-grow: 1;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .copy-btn {
            background-color: #2ecc71;
            margin-left: 10px;
            padding: 8px 16px;
            font-size: 14px;
        }
        .copy-btn:hover {
            background-color: #27ae60;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 14px;
            color: #7f8c8d;
        }
        .debug-panel {
            margin-top: 30px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        #debug-btn {
            background-color: #e74c3c;
        }
        #debug-btn:hover {
            background-color: #c0392b;
        }
        #debug-info {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            overflow-x: auto;
            border: 1px solid #e9ecef;
        }

        /* 配置对话框样式 */
        .config-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .config-modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .config-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        .config-close:hover {
            color: #e74c3c;
        }
        .config-section {
            margin-bottom: 25px;
        }
        .config-section h4 {
            margin-bottom: 10px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .config-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            margin-bottom: 10px;
        }
        .config-textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
        }
        .config-buttons {
            text-align: right;
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .config-btn {
            padding: 10px 20px;
            margin-left: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .config-btn-primary {
            background-color: #3498db;
            color: white;
        }
        .config-btn-primary:hover {
            background-color: #2980b9;
        }
        .config-btn-secondary {
            background-color: #95a5a6;
            color: white;
        }
        .config-btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .config-btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .config-btn-danger:hover {
            background-color: #c0392b;
        }
        .theme-selector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .theme-btn {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        .theme-btn:hover {
            opacity: 0.8;
        }
        .theme-btn.active {
            background-color: #e74c3c;
        }

        /* 深色主题下的主题选择器 */
        body.dark-theme .theme-selector {
            background-color: rgba(45, 45, 45, 0.9);
            border: 1px solid #555555;
        }

        /* 深色主题 */
        body.dark-theme {
            background-color: #2c3e50;
            color: #e0e0e0;
        }
        body.dark-theme .container {
            background-color: #34495e;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        body.dark-theme h1 {
            color: #ffffff;
        }
        body.dark-theme .tab {
            border-bottom: 2px solid #555555;
            color: #cccccc;
            background-color: transparent;
        }
        body.dark-theme .tab:hover {
            background-color: #404040;
        }
        body.dark-theme .tab.active {
            border-bottom: 2px solid #4a9eff;
            color: #4a9eff;
            background-color: #333333;
        }
        body.dark-theme textarea {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme textarea:focus {
            border-color: #4a9eff;
            outline: none;
        }
        body.dark-theme textarea::placeholder {
            color: #888888;
        }
        body.dark-theme button {
            background-color: #4a9eff;
            color: #ffffff;
        }
        body.dark-theme button:hover {
            background-color: #357abd;
        }
        body.dark-theme .result {
            background-color: #1e1e1e;
            border-left: 4px solid #4a9eff;
            color: #e0e0e0;
        }
        body.dark-theme .copy-btn {
            background-color: #28a745;
        }
        body.dark-theme .copy-btn:hover {
            background-color: #1e7e34;
        }
        body.dark-theme .footer {
            color: #888888;
        }
        body.dark-theme .debug-panel {
            border-top: 1px solid #555555;
        }
        body.dark-theme textarea {
            background-color: #2c3e50;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme textarea:focus {
            border-color: #3498db;
            outline: none;
        }
        body.dark-theme textarea::placeholder {
            color: #888888;
        }
        body.dark-theme .result {
            background-color: #2c3e50;
            border-left: 4px solid #3498db;
        }
        body.dark-theme #debug-info {
            background-color: #2c3e50;
            color: #e0e0e0;
            border: 1px solid #555555;
        }

        /* 深色主题下的配置对话框 */
        body.dark-theme .config-modal-content {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }
        body.dark-theme .config-section h4 {
            color: #ffffff;
            border-bottom: 2px solid #4a9eff;
        }
        body.dark-theme .config-input,
        body.dark-theme .config-textarea {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme .config-input:focus,
        body.dark-theme .config-textarea:focus {
            border-color: #4a9eff;
            outline: none;
        }
        body.dark-theme .config-buttons {
            border-top: 1px solid #555555;
        }

        /* 粉色主题 */
        body.pink-theme {
            background-color: #fdf2f8;
            color: #831843;
        }
        body.pink-theme .container {
            background-color: #fce7f3;
            box-shadow: 0 2px 10px rgba(219, 39, 119, 0.1);
        }
        body.pink-theme h1 {
            color: #be185d;
        }
        body.pink-theme .tab.active {
            border-bottom: 2px solid #ec4899;
            color: #ec4899;
        }
        body.pink-theme button {
            background-color: #ec4899;
        }
        body.pink-theme button:hover {
            background-color: #be185d;
        }
        body.pink-theme .result {
            background-color: #fdf2f8;
            border-left: 4px solid #ec4899;
        }

        /* 绿色主题 */
        body.green-theme {
            background-color: #f0fdf4;
            color: #14532d;
        }
        body.green-theme .container {
            background-color: #dcfce7;
            box-shadow: 0 2px 10px rgba(34, 197, 94, 0.1);
        }
        body.green-theme h1 {
            color: #15803d;
        }
        body.green-theme .tab.active {
            border-bottom: 2px solid #22c55e;
            color: #22c55e;
        }
        body.green-theme button {
            background-color: #22c55e;
        }
        body.green-theme button:hover {
            background-color: #15803d;
        }
        body.green-theme .result {
            background-color: #f0fdf4;
            border-left: 4px solid #22c55e;
        }
    </style>
</head>
<body>
    <div class="theme-selector">
        <button class="theme-btn active" data-theme="default">默认</button>
        <button class="theme-btn" data-theme="dark">深色</button>
        <button class="theme-btn" data-theme="pink">粉色</button>
        <button class="theme-btn" data-theme="green">绿色</button>
        <button class="theme-btn" id="config-btn-header" style="background-color: #f39c12;">⚙️</button>
    </div>

    <div class="container">
        <h1>喵语翻译器</h1>

        <div class="tabs">
            <div class="tab active" id="encrypt-tab">加密</div>
            <div class="tab" id="decrypt-tab">解密</div>
        </div>
        
        <div id="encrypt-panel">
            <textarea id="encrypt-input" placeholder="请输入要加密的文本..." maxlength="5000"></textarea>
            <div class="char-counter" id="encrypt-counter">0 / 5000 字符</div>
            <div class="length-warning" id="encrypt-warning">
                ⚠️ 文本较长，加密后的结果可能很大，建议分段处理或使用较短的文本。
            </div>
            <button id="encrypt-btn">加密</button>

            <div class="result result-container" id="encrypt-result" style="display: none;">
                <h3>加密结果：</h3>
                <div class="result-preview" id="encrypt-output"></div>
                <div class="result-actions">
                    <div class="result-stats" id="encrypt-stats"></div>
                    <button id="copy-encrypt" class="copy-btn">复制结果</button>
                    <button id="download-encrypt" class="copy-btn" style="background-color: #9b59b6;">下载文件</button>
                </div>
            </div>
        </div>

        <div id="decrypt-panel" style="display: none;">
            <textarea id="decrypt-input" placeholder="请输入要解密的文本..."></textarea>
            <div class="char-counter" id="decrypt-counter">0 字符</div>
            <div class="length-warning" id="decrypt-warning">
                ⚠️ 输入文本较长，解密可能需要一些时间，请耐心等待。
            </div>
            <button id="decrypt-btn">解密</button>

            <div class="result result-container" id="decrypt-result" style="display: none;">
                <h3>解密结果：</h3>
                <div class="result-preview" id="decrypt-output"></div>
                <div class="result-actions">
                    <div class="result-stats" id="decrypt-stats"></div>
                    <button id="copy-decrypt" class="copy-btn">复制结果</button>
                    <button id="download-decrypt" class="copy-btn" style="background-color: #9b59b6;">下载文件</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>喵语翻译器 &copy; 2025</p>
    </div>

    <!-- 配置对话框 -->
    <div id="config-modal" class="config-modal">
        <div class="config-modal-content">
            <span class="config-close">&times;</span>
            <h2>配置参数</h2>

            <div class="config-section">
                <h4>加密参数</h4>
                <label>版本号 (VERSION):</label>
                <input type="text" id="config-version" class="config-input" placeholder="例如: MiaoV0721">

                <label>密钥 (KEY):</label>
                <input type="text" id="config-key" class="config-input" placeholder="例如: 2hY8u5Pq3zRv7xW4jN0c1fT9eD6aXsB0">

                <label>盐值 (SALT):</label>
                <input type="text" id="config-salt" class="config-input" placeholder="例如: K7mLp2oQ9nRz8sV4tC1uJ6yF3dH5gXbE">
            </div>

            <div class="config-section">
                <h4>喵语词汇</h4>
                <label>喵语短语 (每行一个):</label>
                <textarea id="config-phrases" class="config-textarea" placeholder="喵&#10;喵喵&#10;喵~&#10;喵呜&#10;喵嗷&#10;喵喵喵"></textarea>
            </div>

            <div class="config-section">
                <h4>标点符号</h4>
                <label>标点符号 (每行一个):</label>
                <textarea id="config-punctuations" class="config-textarea" placeholder="，&#10;。&#10;！&#10;？&#10;~&#10;..."></textarea>
            </div>

            <div class="config-buttons">
                <button class="config-btn config-btn-danger" id="config-reset">重置为默认</button>
                <button class="config-btn config-btn-secondary" id="config-cancel">取消</button>
                <button class="config-btn config-btn-primary" id="config-save">保存配置</button>
            </div>
        </div>
    </div>

    <script>
        // 零宽字符集
        const ZERO_WIDTH_CHARS = [
            '\u200b',
            '\u200c',
            '\u200d',
            '\u2060',
            '\u200e',
            '\u200f',
            '\ufeff',
        ];

        // 默认配置
        const DEFAULT_CONFIG = {
            VERSION: "MiaoV0721",
            KEY: "2hY8u5Pq3zRv7xW4jN0c1fT9eD6aXsB0",
            SALT: "K7mLp2oQ9nRz8sV4tC1uJ6yF3dH5gXbE",
            PHRASES: ["喵", "喵喵", "喵~", "喵呜", "喵嗷", "喵喵喵"],
            PUNCTUATIONS: ["，", "。", "！", "？", "~", "..."],
            MAX_INPUT_LENGTH: 5000,  // 最大输入长度
            CHUNK_SIZE: 1000,        // 分块处理大小
            WARNING_LENGTH: 100,     // 降低警告长度阈值
            ULTRA_COMPACT_MODE: true // 启用超紧凑模式
        };

        // 当前配置（可以被用户修改）
        let CONFIG = { ...DEFAULT_CONFIG };

        // 为了向后兼容，保留原有的变量名
        let KEY = CONFIG.KEY;
        let SALT = CONFIG.SALT;
        let VERSION = CONFIG.VERSION;
        let PHRASES = [...CONFIG.PHRASES];
        let PUNCTUATIONS = [...CONFIG.PUNCTUATIONS];

        // 配置管理函数
        function loadConfig() {
            console.log('开始加载配置...');
            const savedConfig = localStorage.getItem('miao-config');
            console.log('从localStorage读取的配置:', savedConfig);
            if (savedConfig) {
                try {
                    const parsed = JSON.parse(savedConfig);
                    console.log('解析后的配置:', parsed);
                    CONFIG = { ...DEFAULT_CONFIG, ...parsed };
                    console.log('合并后的CONFIG:', CONFIG);
                    updateVariables();
                } catch (e) {
                    console.warn('配置加载失败，使用默认配置:', e);
                }
            } else {
                console.log('没有找到保存的配置，使用默认配置');
            }
        }

        function saveConfig() {
            localStorage.setItem('miao-config', JSON.stringify(CONFIG));
            updateVariables();
        }

        function updateVariables() {
            KEY = CONFIG.KEY;
            SALT = CONFIG.SALT;
            VERSION = CONFIG.VERSION;
            PHRASES = [...CONFIG.PHRASES];
            PUNCTUATIONS = [...CONFIG.PUNCTUATIONS];
            console.log('配置已更新:', { KEY, SALT, VERSION, PHRASES, PUNCTUATIONS });
        }

        function resetConfig() {
            CONFIG = { ...DEFAULT_CONFIG };
            updateVariables();
            updateConfigUI();
        }

        function updateConfigUI() {
            document.getElementById('config-version').value = CONFIG.VERSION;
            document.getElementById('config-key').value = CONFIG.KEY;
            document.getElementById('config-salt').value = CONFIG.SALT;
            document.getElementById('config-phrases').value = CONFIG.PHRASES.join('\n');
            document.getElementById('config-punctuations').value = CONFIG.PUNCTUATIONS.join('\n');
        }

        function getConfigFromUI() {
            const phrases = document.getElementById('config-phrases').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            const punctuations = document.getElementById('config-punctuations').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            return {
                VERSION: document.getElementById('config-version').value.trim() || DEFAULT_CONFIG.VERSION,
                KEY: document.getElementById('config-key').value.trim() || DEFAULT_CONFIG.KEY,
                SALT: document.getElementById('config-salt').value.trim() || DEFAULT_CONFIG.SALT,
                PHRASES: phrases.length > 0 ? phrases : DEFAULT_CONFIG.PHRASES,
                PUNCTUATIONS: punctuations.length > 0 ? punctuations : DEFAULT_CONFIG.PUNCTUATIONS
            };
        }

        // 修复的Base64字符到零宽字符组合的映射
        function createBase64ToZeroWidthMap() {
            const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            const mapping = {};

            // 使用2个零宽字符的组合
            const COMBO_LENGTH = 2;

            // 为每个Base64字符创建唯一的零宽字符组合
            for (let i = 0; i < base64Chars.length; i++) {
                const char = base64Chars[i];

                // 使用确定性算法生成唯一组合
                const firstIndex = i % ZERO_WIDTH_CHARS.length;
                const secondIndex = Math.floor(i / ZERO_WIDTH_CHARS.length) % ZERO_WIDTH_CHARS.length;

                const zeroWidthCombo = ZERO_WIDTH_CHARS[firstIndex] + ZERO_WIDTH_CHARS[secondIndex];
                mapping[char] = zeroWidthCombo;
            }

            // 验证映射的唯一性并修复冲突
            const usedCombos = new Set();
            const conflicts = [];

            for (const [char, combo] of Object.entries(mapping)) {
                if (usedCombos.has(combo)) {
                    conflicts.push(char);
                } else {
                    usedCombos.add(combo);
                }
            }

            // 修复冲突
            for (let i = 0; i < conflicts.length; i++) {
                const char = conflicts[i];
                const charIndex = base64Chars.indexOf(char);

                // 使用不同的算法生成新的组合
                let newCombo;
                let attempts = 0;
                do {
                    const offset = attempts + 1;
                    const firstIndex = (charIndex + offset) % ZERO_WIDTH_CHARS.length;
                    const secondIndex = (charIndex + offset * 2) % ZERO_WIDTH_CHARS.length;
                    newCombo = ZERO_WIDTH_CHARS[firstIndex] + ZERO_WIDTH_CHARS[secondIndex];
                    attempts++;
                } while (usedCombos.has(newCombo) && attempts < 10);

                mapping[char] = newCombo;
                usedCombos.add(newCombo);
            }

            console.log(`创建了 ${Object.keys(mapping).length} 个映射，冲突修复: ${conflicts.length}`);
            return mapping;
        }

        // 混淆函数
        function starResonanceScramble(str, key, salt) {
            try {
                // 1. 将输入字符串与盐值组合
                const saltedInput = str + ":" + salt;
                
                // 2. 使用密钥的特征值进行额外处理
                let result = '';
                const keyChars = Array.from(key);
                const keySum = keyChars.reduce((sum, char) => sum + char.charCodeAt(0), 0);
                
                for (let i = 0; i < saltedInput.length; i++) {
                    const charCode = saltedInput.charCodeAt(i);
                    const keyChar = key.charCodeAt(i % key.length);
                    const xorResult = charCode ^ keyChar;
                    
                    // 根据位置和密钥特征值进行偏移
                    const offset = (i % 3 === 0) ? (keySum % 7) : ((i % 3 === 1) ? -(keySum % 5) : (keySum % 3));
                    const finalCharCode = (xorResult + offset + 65536) % 65536; // 确保在有效Unicode范围内
                    
                    result += String.fromCharCode(finalCharCode);
                }
                
                // 3. 添加版本标记
                return VERSION + ":" + result;
            } catch (e) {
                console.error("混淆过程中出错:", e);
                throw e;
            }
        }

        // 解混淆函数
        function starResonanceUnscramble(scrambled, key, salt) {
            try {
                // 1. 验证并移除版本标记
                if (!scrambled.startsWith(VERSION + ":")) {
                    console.error("版本标记不匹配:", scrambled.substring(0, 20));
                    throw new Error("无效的加密格式或版本不匹配");
                }
                
                const dataWithoutVersion = scrambled.substring(VERSION.length + 1);
                
                // 2. 反向应用额外处理
                let result = '';
                const keyChars = Array.from(key);
                const keySum = keyChars.reduce((sum, char) => sum + char.charCodeAt(0), 0);
                
                for (let i = 0; i < dataWithoutVersion.length; i++) {
                    // 反向应用额外处理
                    const charCode = dataWithoutVersion.charCodeAt(i);
                    const offset = (i % 3 === 0) ? (keySum % 7) : ((i % 3 === 1) ? -(keySum % 5) : (keySum % 3));
                    const unshiftedCharCode = (charCode - offset + 65536) % 65536; // 确保在有效Unicode范围内
                    
                    // XOR解密
                    const keyChar = key.charCodeAt(i % key.length);
                    const originalCharCode = unshiftedCharCode ^ keyChar;
                    
                    result += String.fromCharCode(originalCharCode);
                }
                
                // 3. 移除盐值 - 改进版本，更好地处理边界情况
                const saltMarker = ":" + salt;
                const saltIndex = result.lastIndexOf(saltMarker);

                if (saltIndex === -1) {
                    console.error("无法找到完整的盐值标记，尝试其他方法");
                    console.log("解混淆结果:", result);
                    console.log("期望的盐值标记:", saltMarker);

                    // 尝试查找任何冒号分隔符
                    const lastColonIndex = result.lastIndexOf(":");
                    if (lastColonIndex !== -1) {
                        const possibleSalt = result.substring(lastColonIndex + 1);
                        console.log("找到的可能盐值:", possibleSalt);

                        // 检查是否是预期的盐值
                        if (possibleSalt === salt) {
                            console.log("找到匹配的盐值，使用冒号分隔点");
                            return result.substring(0, lastColonIndex);
                        } else {
                            console.log("盐值不匹配，尝试直接返回结果");
                            // 如果盐值不匹配，可能是解混淆过程中的字符编码问题
                            // 尝试返回去掉最后部分的结果
                            return result.substring(0, lastColonIndex);
                        }
                    }

                    // 最后的备用方案：检查结果是否已经是有效的原始消息
                    console.log("无法找到盐值分隔符，检查结果是否有效");
                    if (result.length > salt.length + 1) {
                        // 尝试去掉可能的盐值后缀
                        const withoutSuffix = result.substring(0, result.length - salt.length - 1);
                        console.log("尝试去掉后缀:", withoutSuffix);
                        return withoutSuffix;
                    }

                    throw new Error("解密失败：无效的数据格式");
                }

                return result.substring(0, saltIndex);
            } catch (e) {
                console.error("解混淆过程中出错:", e);
                throw e;
            }
        }

        // 超级优化的加密消息函数 - 最小化输出长度
        function encryptMessage(message) {
            try {
                console.log(`开始加密消息: "${message}"`);

                if (CONFIG.ULTRA_COMPACT_MODE) {
                    // 超紧凑模式：跳过复杂的混淆，直接使用简单编码
                    return encryptMessageUltraCompact(message);
                }

                // 1. 使用混淆函数处理原始消息
                const scrambledMessage = starResonanceScramble(message, KEY, SALT);
                console.log(`混淆后消息长度: ${scrambledMessage.length}`);

                // 2. 创建Base64到零宽字符的映射
                const b64ToZwMap = createBase64ToZeroWidthMap();

                // 3. 将混淆后的消息转为Base64
                const base64Message = btoa(unescape(encodeURIComponent(scrambledMessage)));
                console.log(`Base64消息: "${base64Message}" (长度: ${base64Message.length})`);

                // 4. 将Base64转为零宽字符
                let zeroWidthMessage = "";
                for (let i = 0; i < base64Message.length; i++) {
                    const b64Char = base64Message[i];
                    const zwCombo = b64ToZwMap[b64Char];
                    if (!zwCombo) {
                        console.error(`Base64字符 '${b64Char}' 没有对应的零宽字符映射`);
                        throw new Error(`映射错误: 字符 '${b64Char}' 未找到映射`);
                    }
                    zeroWidthMessage += zwCombo;
                }
                console.log(`零宽字符消息长度: ${zeroWidthMessage.length}`);

                // 5. 生成简化的喵语文本
                const result = generateSimpleMeowText(zeroWidthMessage);
                console.log(`最终加密结果长度: ${result.length}`);
                return result;
            } catch (e) {
                console.error("加密过程中出错:", e);
                throw new Error(`加密失败: ${e.message}`);
            }
        }

        // 超紧凑加密模式 - 优化的映射（平衡压缩比和可靠性）
        function encryptMessageUltraCompact(message) {
            console.log(`使用超紧凑模式加密: "${message}"`);

            // 1. 简单的字符编码，不使用复杂的混淆
            const encoded = btoa(unescape(encodeURIComponent(message + ":" + VERSION)));
            console.log(`Base64编码: "${encoded}" (长度: ${encoded.length})`);

            // 2. 使用6位编码（Base64字符只需要6位就够了）
            const result = PHRASES[0]; // 开头的"喵"
            let zwPart = "";

            // Base64字符集索引映射
            const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

            for (let i = 0; i < encoded.length; i++) {
                const char = encoded[i];
                const charIndex = base64Chars.indexOf(char);

                if (charIndex !== -1) {
                    // 将索引转换为6位二进制（0-63需要6位）
                    const binaryStr = charIndex.toString(2).padStart(6, '0');
                    console.log(`字符 "${char}" (索引${charIndex}) -> 二进制: ${binaryStr}`);

                    for (let j = 0; j < binaryStr.length; j++) {
                        const bit = binaryStr[j];
                        // 0 -> 第一个零宽字符，1 -> 第二个零宽字符
                        zwPart += bit === '0' ? ZERO_WIDTH_CHARS[0] : ZERO_WIDTH_CHARS[1];
                    }
                } else {
                    console.warn(`未知的Base64字符: "${char}"`);
                    // 使用默认的6位编码
                    zwPart += ZERO_WIDTH_CHARS[0].repeat(6);
                }
            }

            const finalResult = result + zwPart;
            console.log(`超紧凑模式结果长度: ${finalResult.length}, 压缩比: ${(finalResult.length/message.length).toFixed(2)}:1`);

            return finalResult;
        }

        // 极度优化的紧凑喵语文本生成 - 最小化输出长度
        function generateSimpleMeowText(zeroWidthMessage) {
            // 更新为新的组合长度
            const COMBO_LENGTH = 2; // 与映射函数保持一致
            const completeComboCount = Math.floor(zeroWidthMessage.length / COMBO_LENGTH);
            const usableLength = completeComboCount * COMBO_LENGTH;

            console.log(`零宽字符总长度: ${zeroWidthMessage.length}, 完整组合数: ${completeComboCount}, 可用长度: ${usableLength}`);

            // 极简模式：最少的可见字符，最大化零宽字符密度
            let result = "";

            // 只在开头添加一个最短的喵语词
            result += PHRASES[0]; // "喵"

            // 直接添加所有零宽字符，不再分段
            result += zeroWidthMessage.substring(0, usableLength);

            console.log(`生成的喵语文本长度: ${result.length}, 零宽字符占比: ${(usableLength/result.length*100).toFixed(1)}%`);

            return result;
        }

        // 分块处理大文本
        function processLargeText(text, operation) {
            const chunkSize = CONFIG.CHUNK_SIZE || 1000;
            if (text.length <= chunkSize) {
                return operation(text);
            }

            const chunks = [];
            for (let i = 0; i < text.length; i += chunkSize) {
                chunks.push(text.substring(i, i + chunkSize));
            }

            console.log(`分块处理: ${chunks.length} 个块，每块最大 ${chunkSize} 字符`);

            const results = chunks.map((chunk, index) => {
                console.log(`处理第 ${index + 1}/${chunks.length} 块`);
                return operation(chunk);
            });

            return results.join('');
        }

        // 检查文本长度并显示警告
        function checkTextLength(text, warningElement, counterElement, maxLength) {
            const length = text.length;
            const warningThreshold = CONFIG.WARNING_LENGTH || 1000;

            if (counterElement) {
                if (maxLength) {
                    counterElement.textContent = `${length} / ${maxLength} 字符`;
                    counterElement.className = 'char-counter';
                    if (length > maxLength * 0.8) {
                        counterElement.className += ' warning';
                    }
                    if (length > maxLength * 0.95) {
                        counterElement.className += ' danger';
                    }
                } else {
                    counterElement.textContent = `${length} 字符`;
                }
            }

            if (warningElement) {
                if (length > warningThreshold) {
                    warningElement.style.display = 'block';
                } else {
                    warningElement.style.display = 'none';
                }
            }

            return length <= (maxLength || Infinity);
        }

        // 优化后的解密消息函数，提高解密可靠性 - 修复版本，增加调试信息
        function decryptMessage(encryptedMessage) {
            try {
                console.log(`开始解密消息，长度: ${encryptedMessage.length}`);

                // 检测是否为超紧凑模式
                if (CONFIG.ULTRA_COMPACT_MODE) {
                    return decryptMessageUltraCompact(encryptedMessage);
                }

                // 1. 创建Base64到零宽字符的映射
                const b64ToZwMap = createBase64ToZeroWidthMap();

                // 创建反向映射
                const zwToB64Map = {};
                for (const [key, value] of Object.entries(b64ToZwMap)) {
                    zwToB64Map[value] = key;
                }
                console.log(`创建了 ${Object.keys(zwToB64Map).length} 个反向映射`);

                // 2. 提取所有零宽字符
                const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                const zeroWidthMatches = encryptedMessage.match(zeroWidthCharsRegex) || [];
                const zeroWidthOnly = zeroWidthMatches.join('');

                console.log(`提取到 ${zeroWidthOnly.length} 个零宽字符`);
                console.log(`零宽字符预览: ${Array.from(zeroWidthOnly.substring(0, 12)).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join(' ')}`);

                // 3. 将零宽字符转回Base64 - 使用固定长度分组
                let base64Message = "";
                const COMBO_LENGTH = 2; // 更新为新的组合长度

                // 按固定长度分组处理 - 改进版本，增加错误处理
                let unmappedCount = 0;
                for (let i = 0; i < zeroWidthOnly.length; i += COMBO_LENGTH) {
                    if (i + COMBO_LENGTH <= zeroWidthOnly.length) {
                        const zwCombo = zeroWidthOnly.substring(i, i + COMBO_LENGTH);

                        if (zwCombo in zwToB64Map) {
                            base64Message += zwToB64Map[zwCombo];
                        } else {
                            unmappedCount++;
                            console.warn(`无法找到零宽字符组合的映射 (位置 ${i}): ${Array.from(zwCombo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('')}`);

                            // 尝试查找最相似的映射
                            let bestMatch = null;
                            let minDifference = Infinity;

                            for (const [mappedCombo, b64Char] of Object.entries(zwToB64Map)) {
                                let difference = 0;
                                for (let j = 0; j < COMBO_LENGTH; j++) {
                                    if (zwCombo[j] !== mappedCombo[j]) {
                                        difference++;
                                    }
                                }
                                if (difference < minDifference) {
                                    minDifference = difference;
                                    bestMatch = b64Char;
                                }
                            }

                            if (bestMatch && minDifference <= 1) { // 降低容错阈值
                                console.log(`使用最相似的映射: ${bestMatch} (差异: ${minDifference})`);
                                base64Message += bestMatch;
                            } else {
                                console.error(`无法找到合适的替代映射，跳过此组合`);
                                // 不添加任何字符，这可能导致Base64不完整
                            }
                        }
                    } else {
                        // 处理不完整的最后一组
                        console.warn(`剩余零宽字符长度不足: ${zeroWidthOnly.length - i}`);
                        break;
                    }
                }

                console.log(`未映射的组合数量: ${unmappedCount}`);

                console.log(`解析出的Base64字符串长度: ${base64Message.length}`);

                // 4. 修复Base64字符串的填充
                base64Message = fixBase64Padding(base64Message);

                // 5. 检查Base64格式是否有效
                console.log(`最终Base64字符串: "${base64Message}"`);
                if (!isValidBase64(base64Message)) {
                    console.error("解析出的Base64字符串无效:", base64Message);
                    console.log("尝试修复Base64字符串...");

                    // 尝试修复常见的Base64问题
                    let fixedBase64 = base64Message;

                    // 移除无效字符
                    fixedBase64 = fixedBase64.replace(/[^A-Za-z0-9+/=]/g, '');

                    // 重新修复填充
                    fixedBase64 = fixBase64Padding(fixedBase64);

                    console.log(`修复后的Base64: "${fixedBase64}"`);

                    if (isValidBase64(fixedBase64)) {
                        console.log("Base64修复成功");
                        base64Message = fixedBase64;
                    } else {
                        throw new Error("解密失败：无效的Base64格式，修复失败");
                    }
                }

                // 6. 将Base64解码回混淆后的消息
                let scrambledMessage;
                try {
                    const decodedData = atob(base64Message);
                    scrambledMessage = decodeURIComponent(escape(decodedData));
                } catch (e) {
                    console.warn("标准解码方法失败，尝试备用方法:", e);

                    // 备用解码方法，处理非ASCII字符
                    try {
                        const bytes = [];
                        const decodedData = atob(base64Message);
                        for (let i = 0; i < decodedData.length; i++) {
                            bytes.push(decodedData.charCodeAt(i));
                        }
                        const decoder = new TextDecoder('utf-8');
                        scrambledMessage = decoder.decode(new Uint8Array(bytes));
                    } catch (backupError) {
                        console.error("备用解码方法也失败:", backupError);
                        throw new Error(`解密失败: 无法解码Base64数据`);
                    }
                }

                // 7. 使用解混淆函数还原原始消息
                return starResonanceUnscramble(scrambledMessage, KEY, SALT);
            } catch (e) {
                console.error("解密错误详情:", e);
                throw new Error(`解密失败: ${e.message}`);
            }
        }

        // 超紧凑解密模式 - 优化的反向映射（6位编码）
        function decryptMessageUltraCompact(encryptedMessage) {
            try {
                console.log(`使用超紧凑模式解密，长度: ${encryptedMessage.length}`);

                // 1. 提取零宽字符（跳过开头的"喵"）
                const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                const zeroWidthMatches = encryptedMessage.match(zeroWidthCharsRegex) || [];

                console.log(`提取到 ${zeroWidthMatches.length} 个零宽字符`);

                // 2. 调试零宽字符类型
                console.log(`零宽字符类型统计:`);
                const zwTypeCount = {};
                zeroWidthMatches.forEach(zw => {
                    const code = zw.charCodeAt(0).toString(16).padStart(4, '0');
                    zwTypeCount[code] = (zwTypeCount[code] || 0) + 1;
                });
                console.log(zwTypeCount);

                // 检查是否只有两种零宽字符
                const uniqueZwChars = [...new Set(zeroWidthMatches)];
                console.log(`唯一的零宽字符数量: ${uniqueZwChars.length}`);
                uniqueZwChars.forEach((zw, index) => {
                    console.log(`  [${index}] \\u${zw.charCodeAt(0).toString(16).padStart(4, '0')}`);
                });

                // 3. 将零宽字符序列转回Base64字符
                let base64Message = "";
                const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

                console.log(`Base64字符集长度: ${base64Chars.length}`);
                console.log(`期望的零宽字符: [0]=${ZERO_WIDTH_CHARS[0].charCodeAt(0).toString(16)}, [1]=${ZERO_WIDTH_CHARS[1].charCodeAt(0).toString(16)}`);

                // 每6个零宽字符代表一个Base64字符的索引
                for (let i = 0; i < zeroWidthMatches.length; i += 6) {
                    if (i + 5 < zeroWidthMatches.length) {
                        let binaryStr = "";

                        // 重构6位二进制字符串
                        for (let j = 0; j < 6; j++) {
                            const zwChar = zeroWidthMatches[i + j];
                            // 第一个零宽字符 -> 0，第二个零宽字符 -> 1
                            if (zwChar === ZERO_WIDTH_CHARS[0]) {
                                binaryStr += '0';
                            } else if (zwChar === ZERO_WIDTH_CHARS[1]) {
                                binaryStr += '1';
                            } else {
                                console.warn(`意外的零宽字符[${i+j}]: \\u${zwChar.charCodeAt(0).toString(16).padStart(4, '0')}`);
                                binaryStr += '0'; // 默认为0
                            }
                        }

                        // 将二进制转换为Base64字符索引
                        const charIndex = parseInt(binaryStr, 2);

                        if (charIndex >= 0 && charIndex < base64Chars.length) {
                            const char = base64Chars[charIndex];
                            base64Message += char;
                            if (i < 30) { // 只显示前几个的详细信息
                                console.log(`[${Math.floor(i/6)}] 二进制 ${binaryStr} -> 索引 ${charIndex} -> 字符 "${char}"`);
                            }
                        } else {
                            console.warn(`无效的字符索引: ${charIndex}, 超出范围 [0, ${base64Chars.length-1}]`);
                            base64Message += 'A'; // 默认字符
                        }
                    }
                }

                console.log(`重构的Base64: "${base64Message}" (长度: ${base64Message.length})`);

                // 3. 详细分析重构的Base64
                console.log(`Base64字符详细分析:`);
                for (let i = 0; i < Math.min(base64Message.length, 10); i++) {
                    const char = base64Message[i];
                    const code = char.charCodeAt(0);
                    const isValid = /^[A-Za-z0-9+/=]$/.test(char);
                    console.log(`  [${i}] "${char}" (${code}) 有效: ${isValid}`);
                }

                // 4. 修复Base64填充
                if (base64Message.length === 0) {
                    throw new Error("无法重构Base64字符串");
                }

                // 检查零宽字符数量是否正确
                const expectedChars = Math.floor(zeroWidthMatches.length / 6);
                console.log(`零宽字符数量: ${zeroWidthMatches.length}, 期望的Base64字符数: ${expectedChars}, 实际重构: ${base64Message.length}`);

                base64Message = fixBase64Padding(base64Message);
                console.log(`修复填充后的Base64: "${base64Message}" (长度: ${base64Message.length})`);

                // 5. 验证Base64有效性
                if (!isValidBase64(base64Message)) {
                    console.warn(`Base64无效，详细检查...`);

                    // 检查每个字符
                    let invalidChars = [];
                    for (let i = 0; i < base64Message.length; i++) {
                        const char = base64Message[i];
                        if (!/^[A-Za-z0-9+/=]$/.test(char)) {
                            invalidChars.push(`位置${i}: "${char}" (${char.charCodeAt(0)})`);
                        }
                    }

                    if (invalidChars.length > 0) {
                        console.error(`发现无效字符: ${invalidChars.join(', ')}`);
                    }

                    // 强制清理
                    base64Message = base64Message.replace(/[^A-Za-z0-9+/=]/g, '');
                    base64Message = fixBase64Padding(base64Message);
                    console.log(`强制清理后: "${base64Message}"`);

                    if (!isValidBase64(base64Message)) {
                        console.error(`清理后仍然无效，Base64长度: ${base64Message.length}`);
                        throw new Error("Base64字符串无法修复");
                    }
                }

                // 7. 尝试解码Base64 - 增强版本
                let decoded;
                try {
                    // 直接尝试解码
                    decoded = atob(base64Message);
                    console.log(`Base64解码成功`);
                } catch (e) {
                    console.error(`Base64解码失败: ${e.message}`);
                    console.log(`问题Base64: "${base64Message}"`);

                    // 详细分析每个字符并找出问题
                    console.log(`字符分析:`);
                    let cleanBase64 = "";
                    let hasInvalidChars = false;

                    for (let i = 0; i < base64Message.length; i++) {
                        const char = base64Message[i];
                        const code = char.charCodeAt(0);

                        // 检查是否为标准Base64字符
                        const isStandardBase64 = /^[A-Za-z0-9+/=]$/.test(char);
                        const isASCII = code >= 32 && code <= 126;

                        console.log(`  [${i}] "${char}" (U+${code.toString(16).padStart(4, '0')}) ASCII: ${isASCII}, Base64: ${isStandardBase64}`);

                        if (isStandardBase64 && isASCII) {
                            cleanBase64 += char;
                        } else {
                            hasInvalidChars = true;
                            console.log(`    发现无效字符: "${char}" (${code})`);

                            // 根据字符码范围进行智能替换
                            if (code >= 48 && code <= 57) { // 数字范围
                                cleanBase64 += char;
                            } else if (code >= 65 && code <= 90) { // 大写字母范围
                                cleanBase64 += char;
                            } else if (code >= 97 && code <= 122) { // 小写字母范围
                                cleanBase64 += char;
                            } else {
                                // 根据位置选择替换字符
                                const replacements = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
                                const replacement = replacements[i % replacements.length];
                                cleanBase64 += replacement;
                                console.log(`    替换为: "${replacement}"`);
                            }
                        }
                    }

                    if (hasInvalidChars) {
                        console.log(`发现 ${hasInvalidChars} 个无效字符，已进行替换`);
                    }

                    console.log(`清理后的Base64: "${cleanBase64}"`);

                    if (cleanBase64.length === 0) {
                        throw new Error("清理后Base64字符串为空");
                    }

                    // 重新修复填充
                    cleanBase64 = fixBase64Padding(cleanBase64);
                    console.log(`重新修复填充后: "${cleanBase64}"`);

                    try {
                        decoded = atob(cleanBase64);
                        console.log(`清理后Base64解码成功`);
                    } catch (e2) {
                        console.error(`最终解码失败: ${e2.message}`);
                        throw new Error(`Base64解码最终失败: ${e2.message}`);
                    }
                }

                // 8. 解码结果处理
                let result;
                try {
                    result = decodeURIComponent(escape(decoded));
                } catch (e) {
                    // 如果UTF-8解码失败，直接使用原始字符串
                    result = decoded;
                }
                console.log(`解码结果: "${result}" (长度: ${result.length})`);

                // 9. 移除版本标记
                const versionMarker = ":" + VERSION;
                const versionIndex = result.lastIndexOf(versionMarker);
                if (versionIndex !== -1) {
                    const finalResult = result.substring(0, versionIndex);
                    console.log(`移除版本标记后: "${finalResult}"`);
                    return finalResult;
                }

                console.log(`未找到版本标记，直接返回: "${result}"`);
                return result;
            } catch (e) {
                console.error("超紧凑解密失败:", e);
                throw new Error(`超紧凑解密失败: ${e.message}`);
            }
        }

        // 修复Base64填充的辅助函数
        function fixBase64Padding(str) {
            // 移除所有现有的填充字符
            str = str.replace(/=+$/, '');

            // 根据长度添加正确的填充
            const remainder = str.length % 4;
            if (remainder === 2) {
                str += '==';
            } else if (remainder === 3) {
                str += '=';
            }
            // remainder === 0 或 1 时不需要填充（1是无效的，但我们先尝试处理）

            return str;
        }

        // 添加辅助函数检查Base64有效性 - 改进版本
        function isValidBase64(str) {
            try {
                // 检查基本格式
                if (!str) {
                    return false;
                }

                // 检查字符是否都是有效的Base64字符
                const validChars = /^[A-Za-z0-9+/=]+$/;
                if (!validChars.test(str)) {
                    return false;
                }

                // 检查长度是否为4的倍数
                if (str.length % 4 !== 0) {
                    return false;
                }

                // 检查填充字符的位置是否正确
                const paddingMatch = str.match(/=*$/);
                if (paddingMatch) {
                    const paddingLength = paddingMatch[0].length;
                    if (paddingLength > 2) {
                        return false; // 填充字符不能超过2个
                    }

                    // 检查填充前的字符是否有效
                    const withoutPadding = str.substring(0, str.length - paddingLength);
                    if (paddingLength > 0 && withoutPadding.length % 4 !== (4 - paddingLength) % 4) {
                        return false;
                    }
                }

                // 尝试解码
                atob(str);
                return true;
            } catch (e) {
                return false;
            }
        }

        // 主题切换功能
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // 如果是配置按钮，不处理主题切换
                if (this.id === 'config-btn-header') {
                    return;
                }

                const theme = this.getAttribute('data-theme');

                // 移除所有主题类
                document.body.classList.remove('dark-theme', 'pink-theme', 'green-theme');

                // 添加新主题类
                if (theme !== 'default') {
                    document.body.classList.add(theme + '-theme');
                }

                // 更新按钮状态（排除配置按钮）
                document.querySelectorAll('.theme-btn').forEach(b => {
                    if (b.id !== 'config-btn-header') {
                        b.classList.remove('active');
                    }
                });
                this.classList.add('active');

                // 保存主题设置
                localStorage.setItem('theme', theme);
            });
        });

        // 加载保存的主题
        const savedTheme = localStorage.getItem('theme') || 'default';
        if (savedTheme !== 'default') {
            document.body.classList.add(savedTheme + '-theme');
        }

        // 设置主题按钮状态（排除配置按钮）
        document.querySelectorAll('.theme-btn').forEach(b => {
            if (b.id !== 'config-btn-header') {
                if (b.getAttribute('data-theme') === savedTheme) {
                    b.classList.add('active');
                } else {
                    b.classList.remove('active');
                }
            }
        });

        // 确保DOM完全加载后再加载配置
        document.addEventListener('DOMContentLoaded', function() {
            loadConfig();
        });

        // 配置对话框事件监听器
        const configModal = document.getElementById('config-modal');
        const configBtnHeader = document.getElementById('config-btn-header');
        const configClose = document.querySelector('.config-close');
        const configSave = document.getElementById('config-save');
        const configCancel = document.getElementById('config-cancel');
        const configReset = document.getElementById('config-reset');

        // 打开配置对话框
        configBtnHeader.addEventListener('click', function() {
            updateConfigUI();
            configModal.style.display = 'block';
        });

        // 关闭配置对话框
        configClose.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        configCancel.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        // 点击对话框外部关闭
        window.addEventListener('click', function(event) {
            if (event.target === configModal) {
                configModal.style.display = 'none';
            }
        });

        // 保存配置
        configSave.addEventListener('click', function() {
            console.log('保存配置前:', CONFIG);
            const newConfig = getConfigFromUI();
            console.log('从UI获取的新配置:', newConfig);
            CONFIG = newConfig;
            console.log('更新后的CONFIG:', CONFIG);
            saveConfig();
            configModal.style.display = 'none';
            alert('配置已保存！');
        });

        // 重置配置
        configReset.addEventListener('click', function() {
            if (confirm('确定要重置为默认配置吗？这将清除所有自定义设置。')) {
                resetConfig();
                alert('配置已重置为默认值！');
            }
        });

        // 切换标签页
        document.getElementById('encrypt-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('decrypt-tab').classList.remove('active');
            document.getElementById('encrypt-panel').style.display = 'block';
            document.getElementById('decrypt-panel').style.display = 'none';
        });

        document.getElementById('decrypt-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('encrypt-tab').classList.remove('active');
            document.getElementById('decrypt-panel').style.display = 'block';
            document.getElementById('encrypt-panel').style.display = 'none';
        });

        // 文件下载功能
        function downloadText(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 加密按钮点击事件 - 优化版本
        document.getElementById('encrypt-btn').addEventListener('click', function() {
            const input = document.getElementById('encrypt-input').value;
            if (!input) {
                alert('请输入要加密的文本');
                return;
            }

            // 检查文本长度
            if (input.length > CONFIG.MAX_INPUT_LENGTH) {
                alert(`文本长度超过限制（${CONFIG.MAX_INPUT_LENGTH} 字符），请缩短文本或分段处理`);
                return;
            }

            // 显示处理状态
            const btn = this;
            const originalText = btn.textContent;
            btn.textContent = '加密中...';
            btn.disabled = true;

            // 使用 setTimeout 让UI有时间更新
            setTimeout(() => {
                try {
                    const startTime = performance.now();
                    let encrypted;

                    if (input.length > CONFIG.CHUNK_SIZE) {
                        encrypted = processLargeText(input, encryptMessage);
                    } else {
                        encrypted = encryptMessage(input);
                    }

                    const endTime = performance.now();
                    const processingTime = (endTime - startTime).toFixed(2);

                    // 显示结果
                    const outputElement = document.getElementById('encrypt-output');
                    const statsElement = document.getElementById('encrypt-stats');

                    // 限制显示长度，避免页面卡顿
                    const maxDisplayLength = 1000;
                    if (encrypted.length > maxDisplayLength) {
                        outputElement.textContent = encrypted.substring(0, maxDisplayLength) + '\n\n... (结果过长，已截断显示，请使用复制或下载功能获取完整结果)';
                    } else {
                        outputElement.textContent = encrypted;
                    }

                    // 显示统计信息
                    const compressionRatio = (encrypted.length / input.length).toFixed(2);
                    const fileSize = formatFileSize(new Blob([encrypted]).size);
                    statsElement.textContent = `长度: ${encrypted.length} 字符 | 压缩比: ${compressionRatio}:1 | 大小: ${fileSize} | 耗时: ${processingTime}ms`;

                    document.getElementById('encrypt-result').style.display = 'block';

                    // 存储完整结果用于复制和下载
                    window.lastEncryptResult = encrypted;

                } catch (e) {
                    alert(`加密失败: ${e.message}`);
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }, 10);
        });

        // 解密按钮点击事件 - 优化版本
        document.getElementById('decrypt-btn').addEventListener('click', function() {
            const input = document.getElementById('decrypt-input').value;
            if (!input) {
                alert('请输入要解密的文本');
                return;
            }

            // 显示处理状态
            const btn = this;
            const originalText = btn.textContent;
            btn.textContent = '解密中...';
            btn.disabled = true;

            // 使用 setTimeout 让UI有时间更新
            setTimeout(() => {
                try {
                    const startTime = performance.now();
                    const decrypted = decryptMessage(input);
                    const endTime = performance.now();
                    const processingTime = (endTime - startTime).toFixed(2);

                    // 显示结果
                    const outputElement = document.getElementById('decrypt-output');
                    const statsElement = document.getElementById('decrypt-stats');

                    // 限制显示长度，避免页面卡顿
                    const maxDisplayLength = 1000;
                    if (decrypted.length > maxDisplayLength) {
                        outputElement.textContent = decrypted.substring(0, maxDisplayLength) + '\n\n... (结果过长，已截断显示，请使用复制或下载功能获取完整结果)';
                    } else {
                        outputElement.textContent = decrypted;
                    }

                    // 显示统计信息
                    const fileSize = formatFileSize(new Blob([decrypted]).size);
                    statsElement.textContent = `长度: ${decrypted.length} 字符 | 大小: ${fileSize} | 耗时: ${processingTime}ms`;

                    document.getElementById('decrypt-result').style.display = 'block';

                    // 存储完整结果用于复制和下载
                    window.lastDecryptResult = decrypted;

                } catch (e) {
                    alert(`解密失败: ${e.message}`);
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }, 10);
        });

        // 复制加密结果 - 使用完整结果
        document.getElementById('copy-encrypt').addEventListener('click', function() {
            const text = window.lastEncryptResult || document.getElementById('encrypt-output').textContent;
            navigator.clipboard.writeText(text).then(function() {
                alert('已复制到剪贴板');
            }, function() {
                alert('复制失败，请手动复制');
            });
        });

        // 复制解密结果 - 使用完整结果
        document.getElementById('copy-decrypt').addEventListener('click', function() {
            const text = window.lastDecryptResult || document.getElementById('decrypt-output').textContent;
            navigator.clipboard.writeText(text).then(function() {
                alert('已复制到剪贴板');
            }, function() {
                alert('复制失败，请手动复制');
            });
        });

        // 下载加密结果
        document.getElementById('download-encrypt').addEventListener('click', function() {
            const text = window.lastEncryptResult || document.getElementById('encrypt-output').textContent;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            downloadText(text, `encrypted_${timestamp}.txt`);
        });

        // 下载解密结果
        document.getElementById('download-decrypt').addEventListener('click', function() {
            const text = window.lastDecryptResult || document.getElementById('decrypt-output').textContent;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            downloadText(text, `decrypted_${timestamp}.txt`);
        });

        // 输入框字符计数和警告
        document.getElementById('encrypt-input').addEventListener('input', function() {
            checkTextLength(
                this.value,
                document.getElementById('encrypt-warning'),
                document.getElementById('encrypt-counter'),
                CONFIG.MAX_INPUT_LENGTH
            );
        });

        document.getElementById('decrypt-input').addEventListener('input', function() {
            checkTextLength(
                this.value,
                document.getElementById('decrypt-warning'),
                document.getElementById('decrypt-counter')
            );
        });

        // 添加调试按钮和面板
        document.querySelector('.container').insertAdjacentHTML('beforeend', `
            <div class="debug-panel">
                <h3>调试工具</h3>
                <button id="debug-btn">显示调试信息</button>
                <div id="debug-info"></div>
            </div>
        `);

        // 调试按钮点击事件
        document.getElementById('debug-btn').addEventListener('click', async function() {
            const debugInfo = document.getElementById('debug-info');
            if (debugInfo.style.display === 'none') {
                // 收集调试信息
                let info = "";
                
                // 1. 显示关键参数（显示当前实际使用的配置）
                info += "=== 关键参数 ===\n";
                info += `VERSION: ${CONFIG.VERSION}\n`;
                info += `KEY: ${CONFIG.KEY}\n`;
                info += `SALT: ${CONFIG.SALT}\n`;
                info += `PHRASES: [${CONFIG.PHRASES.join(', ')}]\n`;
                info += `PUNCTUATIONS: [${CONFIG.PUNCTUATIONS.join(', ')}]\n\n`;
                
                // 2. 测试零宽字符映射一致性
                info += "=== 零宽字符映射一致性测试 ===\n";
                const testChar = 'A';
                const b64ToZwMap = createBase64ToZeroWidthMap();
                const zwEncoded = b64ToZwMap[testChar];
                
                // 创建反向映射
                const zwToB64Map = {};
                for (const [key, value] of Object.entries(b64ToZwMap)) {
                    zwToB64Map[value] = key;
                }
                
                const b64Decoded = zwToB64Map[zwEncoded];
                
                info += `测试字符: '${testChar}'\n`;
                info += `编码为零宽字符: [${Array.from(zwEncoded).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join(', ')}]\n`;
                info += `解码回Base64: '${b64Decoded}'\n`;
                info += `映射一致性: ${testChar === b64Decoded ? '✓ 正常' : '✗ 错误'}\n\n`;
                
                // 3. 测试加密解密一致性
                info += "=== 加密解密一致性测试 ===\n";
                const testMessage = "测试消息123";

                try {
                    // 直接测试混淆函数（使用当前配置）
                    const scrambled = starResonanceScramble(testMessage, CONFIG.KEY, CONFIG.SALT);
                    info += `原始消息: "${testMessage}" (长度: ${testMessage.length})\n`;
                    info += `混淆后长度: ${scrambled.length}\n`;
                    info += `混淆后预览: "${scrambled.substring(0, 30)}${scrambled.length > 30 ? '...' : ''}"\n`;

                    // 分析混淆后的字符分布
                    const charTypes = {
                        ascii: 0,
                        chinese: 0,
                        special: 0,
                        control: 0
                    };

                    for (let i = 0; i < scrambled.length; i++) {
                        const code = scrambled.charCodeAt(i);
                        if (code < 128) {
                            charTypes.ascii++;
                        } else if (code >= 0x4e00 && code <= 0x9fff) {
                            charTypes.chinese++;
                        } else if (code < 32 || code === 127) {
                            charTypes.control++;
                        } else {
                            charTypes.special++;
                        }
                    }

                    info += `字符分布 - ASCII: ${charTypes.ascii}, 中文: ${charTypes.chinese}, 特殊: ${charTypes.special}, 控制: ${charTypes.control}\n`;

                    try {
                        const unscrambled = starResonanceUnscramble(scrambled, CONFIG.KEY, CONFIG.SALT);
                        info += `解混淆后: "${unscrambled}" (长度: ${unscrambled.length})\n`;
                        info += `一致性: ${testMessage === unscrambled ? '✓ 正常' : '✗ 错误'}\n`;

                        if (testMessage !== unscrambled) {
                            info += `差异分析: `;
                            for (let i = 0; i < Math.max(testMessage.length, unscrambled.length); i++) {
                                if (testMessage[i] !== unscrambled[i]) {
                                    info += `位置${i}: "${testMessage[i] || 'null'}" vs "${unscrambled[i] || 'null'}" `;
                                }
                            }
                            info += `\n`;
                        }
                        info += `\n`;
                    } catch (e) {
                        info += `解混淆失败: ${e.message}\n`;
                        info += `错误类型: ${e.constructor.name}\n\n`;
                    }

                    // 4. 测试完整的加密解密流程（包含详细调试）
                    info += "=== 完整加密解密流程测试 ===\n";

                    // 加密消息
                    const startTime = performance.now();
                    const encrypted1 = encryptMessage(testMessage);
                    const encryptTime = performance.now() - startTime;

                    info += `加密耗时: ${encryptTime.toFixed(2)}ms\n`;
                    info += `加密结果长度: ${encrypted1.length}\n`;
                    info += `压缩比: ${(encrypted1.length / testMessage.length).toFixed(2)}:1\n`;
                    info += `加密结果预览: "${encrypted1.substring(0, 50)}${encrypted1.length > 50 ? '...' : ''}"\n`;

                    // 分析零宽字符
                    const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                    const zeroWidthMatches = encrypted1.match(zeroWidthCharsRegex) || [];
                    const visibleChars = encrypted1.replace(zeroWidthCharsRegex, '');

                    info += `零宽字符数量: ${zeroWidthMatches.length}\n`;
                    info += `可见字符数量: ${visibleChars.length}\n`;
                    info += `零宽字符占比: ${(zeroWidthMatches.length / encrypted1.length * 100).toFixed(1)}%\n`;
                    info += `零宽字符长度是否为2的倍数: ${zeroWidthMatches.length % 2 === 0 ? '✓ 是' : '✗ 否'}\n`;

                    // 分析零宽字符类型分布
                    const zwTypeCount = {};
                    zeroWidthMatches.forEach(char => {
                        const code = '\\u' + char.charCodeAt(0).toString(16).padStart(4, '0');
                        zwTypeCount[code] = (zwTypeCount[code] || 0) + 1;
                    });
                    info += `零宽字符类型分布: ${Object.entries(zwTypeCount).map(([type, count]) => `${type}:${count}`).join(', ')}\n`;

                    // 详细调试过程
                    try {
                        // 测试Base64重构过程
                        const b64ToZwMap = createBase64ToZeroWidthMap();
                        const zwToB64Map = {};
                        for (const [key, value] of Object.entries(b64ToZwMap)) {
                            zwToB64Map[value] = key;
                        }

                        const zeroWidthOnly = zeroWidthMatches.join('');
                        info += `提取的零宽字符长度: ${zeroWidthOnly.length}\n`;

                        let base64Reconstructed = "";
                        let unmappedCount = 0;
                        for (let i = 0; i < zeroWidthOnly.length; i += 2) {
                            if (i + 2 <= zeroWidthOnly.length) {
                                const combo = zeroWidthOnly.substring(i, i + 2);
                                if (combo in zwToB64Map) {
                                    base64Reconstructed += zwToB64Map[combo];
                                } else {
                                    unmappedCount++;
                                }
                            }
                        }

                        info += `重构的Base64长度: ${base64Reconstructed.length}\n`;
                        info += `重构的Base64内容: "${base64Reconstructed}"\n`;
                        info += `未映射的组合数: ${unmappedCount}\n`;

                        // 修复Base64填充
                        const fixedBase64 = fixBase64Padding(base64Reconstructed);
                        info += `修复后的Base64: "${fixedBase64}"\n`;
                        info += `Base64有效性: ${isValidBase64(fixedBase64) ? '✓ 有效' : '✗ 无效'}\n`;

                        // 解密过程
                        info += "--- 解密过程 ---\n";
                        const decryptStartTime = performance.now();
                        const decrypted1 = decryptMessage(encrypted1);
                        const decryptTime = performance.now() - decryptStartTime;

                        info += `解密耗时: ${decryptTime.toFixed(2)}ms\n`;
                        info += `解密结果: "${decrypted1}"\n`;
                        info += `解密结果长度: ${decrypted1.length}\n`;
                        info += `解密一致性: ${testMessage === decrypted1 ? '✓ 正常' : '✗ 错误'}\n`;
                        info += `总耗时: ${(encryptTime + decryptTime).toFixed(2)}ms\n`;

                        if (testMessage !== decrypted1) {
                            info += `长度对比: 原始${testMessage.length} vs 解密${decrypted1.length}\n`;
                            info += `字符对比: `;
                            for (let i = 0; i < Math.max(testMessage.length, decrypted1.length); i++) {
                                if (testMessage[i] !== decrypted1[i]) {
                                    info += `[${i}]"${testMessage[i] || '∅'}"≠"${decrypted1[i] || '∅'}" `;
                                }
                            }
                            info += `\n`;
                        }

                    } catch (e) {
                        info += `解密失败: ${e.message}\n`;
                    }
                } catch (e) {
                    info += `测试过程出错: ${e.message}\n`;
                }
                
                // 显示调试信息
                debugInfo.textContent = info;
                debugInfo.style.display = 'block';
                this.textContent = '隐藏调试信息';
            } else {
                debugInfo.style.display = 'none';
                this.textContent = '显示调试信息';
            }
        });
    </script>
</body>
</html>