<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>喵语翻译器</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 20px;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .tabs {
            display: flex;
            margin-bottom: 20px;
        }
        .tab {
            flex: 1;
            text-align: center;
            padding: 12px;
            cursor: pointer;
            border-bottom: 2px solid #ddd;
            transition: all 0.3s;
        }
        .tab.active {
            border-bottom: 2px solid #3498db;
            color: #3498db;
        }
        textarea {
            width: 100%;
            height: 120px;
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            font-family: inherit;
        }
        .char-counter {
            font-size: 12px;
            color: #666;
            text-align: right;
            margin-bottom: 10px;
        }
        .char-counter.warning {
            color: #e67e22;
            font-weight: bold;
        }
        .char-counter.danger {
            color: #e74c3c;
            font-weight: bold;
        }
        .length-warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            display: none;
        }
        .result-container {
            position: relative;
        }
        .result-preview {
            max-height: 200px;
            overflow-y: auto;
            word-break: break-all;
            white-space: pre-wrap;
        }
        .result-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .result-stats {
            font-size: 12px;
            color: #666;
            flex-grow: 1;
        }
        button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #2980b9;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 4px;
            border-left: 4px solid #3498db;
        }
        .copy-btn {
            background-color: #2ecc71;
            margin-left: 10px;
            padding: 8px 16px;
            font-size: 14px;
        }
        .copy-btn:hover {
            background-color: #27ae60;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 14px;
            color: #7f8c8d;
        }
        .debug-panel {
            margin-top: 30px;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
        #debug-btn {
            background-color: #e74c3c;
        }
        #debug-btn:hover {
            background-color: #c0392b;
        }


        /* 配置对话框样式 */
        .config-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        .config-modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 30px;
            border-radius: 12px;
            width: 80%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .config-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        .config-close:hover {
            color: #e74c3c;
        }
        .config-section {
            margin-bottom: 25px;
        }
        .config-section h4 {
            margin-bottom: 10px;
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
        }
        .config-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            margin-bottom: 10px;
        }
        .config-textarea {
            width: 100%;
            height: 80px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
            resize: vertical;
        }
        .config-buttons {
            text-align: right;
            margin-top: 20px;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .config-btn {
            padding: 10px 20px;
            margin-left: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .config-btn-primary {
            background-color: #3498db;
            color: white;
        }
        .config-btn-primary:hover {
            background-color: #2980b9;
        }
        .config-btn-secondary {
            background-color: #95a5a6;
            color: white;
        }
        .config-btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .config-btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .config-btn-danger:hover {
            background-color: #c0392b;
        }
        .theme-selector {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .theme-btn {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        .theme-btn:hover {
            opacity: 0.8;
        }
        .theme-btn.active {
            background-color: #e74c3c;
        }

        /* 深色主题下的主题选择器 */
        body.dark-theme .theme-selector {
            background-color: rgba(45, 45, 45, 0.9);
            border: 1px solid #555555;
        }

        /* 深色主题 */
        body.dark-theme {
            background-color: #2c3e50;
            color: #e0e0e0;
        }
        body.dark-theme .container {
            background-color: #34495e;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        body.dark-theme h1 {
            color: #ffffff;
        }
        body.dark-theme .tab {
            border-bottom: 2px solid #555555;
            color: #cccccc;
            background-color: transparent;
        }
        body.dark-theme .tab:hover {
            background-color: #404040;
        }
        body.dark-theme .tab.active {
            border-bottom: 2px solid #4a9eff;
            color: #4a9eff;
            background-color: #333333;
        }
        body.dark-theme textarea {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme textarea:focus {
            border-color: #4a9eff;
            outline: none;
        }
        body.dark-theme textarea::placeholder {
            color: #888888;
        }
        body.dark-theme button {
            background-color: #4a9eff;
            color: #ffffff;
        }
        body.dark-theme button:hover {
            background-color: #357abd;
        }
        body.dark-theme .result {
            background-color: #1e1e1e;
            border-left: 4px solid #4a9eff;
            color: #e0e0e0;
        }
        body.dark-theme .copy-btn {
            background-color: #28a745;
        }
        body.dark-theme .copy-btn:hover {
            background-color: #1e7e34;
        }
        body.dark-theme .footer {
            color: #888888;
        }
        body.dark-theme .debug-panel {
            border-top: 1px solid #555555;
        }
        body.dark-theme textarea {
            background-color: #2c3e50;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme textarea:focus {
            border-color: #3498db;
            outline: none;
        }
        body.dark-theme textarea::placeholder {
            color: #888888;
        }
        body.dark-theme .result {
            background-color: #2c3e50;
            border-left: 4px solid #3498db;
        }


        /* 深色主题下的配置对话框 */
        body.dark-theme .config-modal-content {
            background-color: #2d2d2d;
            color: #e0e0e0;
        }
        body.dark-theme .config-section h4 {
            color: #ffffff;
            border-bottom: 2px solid #4a9eff;
        }
        body.dark-theme .config-input,
        body.dark-theme .config-textarea {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }
        body.dark-theme .config-input:focus,
        body.dark-theme .config-textarea:focus {
            border-color: #4a9eff;
            outline: none;
        }
        body.dark-theme .config-buttons {
            border-top: 1px solid #555555;
        }

        /* 粉色主题 */
        body.pink-theme {
            background-color: #fdf2f8;
            color: #831843;
        }
        body.pink-theme .container {
            background-color: #fce7f3;
            box-shadow: 0 2px 10px rgba(219, 39, 119, 0.1);
        }
        body.pink-theme h1 {
            color: #be185d;
        }
        body.pink-theme .tab.active {
            border-bottom: 2px solid #ec4899;
            color: #ec4899;
        }
        body.pink-theme button {
            background-color: #ec4899;
        }
        body.pink-theme button:hover {
            background-color: #be185d;
        }
        body.pink-theme .result {
            background-color: #fdf2f8;
            border-left: 4px solid #ec4899;
        }

        /* 绿色主题 */
        body.green-theme {
            background-color: #f0fdf4;
            color: #14532d;
        }
        body.green-theme .container {
            background-color: #dcfce7;
            box-shadow: 0 2px 10px rgba(34, 197, 94, 0.1);
        }
        body.green-theme h1 {
            color: #15803d;
        }
        body.green-theme .tab.active {
            border-bottom: 2px solid #22c55e;
            color: #22c55e;
        }
        body.green-theme button {
            background-color: #22c55e;
        }
        body.green-theme button:hover {
            background-color: #15803d;
        }
        body.green-theme .result {
            background-color: #f0fdf4;
            border-left: 4px solid #22c55e;
        }

        /* 新的调试面板样式 */
        .debug-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        .debug-controls button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .debug-controls button:hover {
            background-color: #2980b9;
        }
        .debug-controls button:active {
            background-color: #1f5f8b;
        }
        #clear-debug-btn {
            background-color: #e74c3c !important;
        }
        #clear-debug-btn:hover {
            background-color: #c0392b !important;
        }

        /* 不同主题下的调试按钮 */
        body.pink-theme .debug-controls button {
            background-color: #ec4899;
        }
        body.pink-theme .debug-controls button:hover {
            background-color: #db2777;
        }
        body.pink-theme .debug-controls button:active {
            background-color: #be185d;
        }

        body.green-theme .debug-controls button {
            background-color: #22c55e;
        }
        body.green-theme .debug-controls button:hover {
            background-color: #16a34a;
        }
        body.green-theme .debug-controls button:active {
            background-color: #15803d;
        }

        body.dark-theme .debug-controls button {
            background-color: #4a90e2;
        }
        body.dark-theme .debug-controls button:hover {
            background-color: #357abd;
        }
        body.dark-theme .debug-controls button:active {
            background-color: #2563eb;
        }
        /* 调试面板基础样式和主题适配 */

        /* 默认主题 */
        .debug-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }
        .debug-section h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        .debug-section pre {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin: 0;
            background-color: #ffffff;
            color: #333333;
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 3px;
        }
        #mapping-test-status, #full-test-status {
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 16px;
        }
        .status-success {
            color: #27ae60;
        }
        .status-error {
            color: #e74c3c;
        }

        /* 深色主题 */
        body.dark-theme .debug-section {
            background-color: #2c3e50;
            border: 1px solid #555555;
        }
        body.dark-theme .debug-section h4 {
            color: #ffffff;
        }
        body.dark-theme .debug-section pre {
            background-color: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #555555;
        }

        /* 粉色主题 */
        body.pink-theme .debug-section {
            background-color: #fdf2f8;
            border: 1px solid #f9a8d4;
        }
        body.pink-theme .debug-section h4 {
            color: #be185d;
        }
        body.pink-theme .debug-section pre {
            background-color: #ffffff;
            color: #333333;
            border: 1px solid #f9a8d4;
        }

        /* 绿色主题 */
        body.green-theme .debug-section {
            background-color: #f0fdf4;
            border: 1px solid #86efac;
        }
        body.green-theme .debug-section h4 {
            color: #15803d;
        }
        body.green-theme .debug-section pre {
            background-color: #ffffff;
            color: #333333;
            border: 1px solid #86efac;
        }
    </style>
</head>
<body>
    <div class="theme-selector">
        <button class="theme-btn active" data-theme="default">默认</button>
        <button class="theme-btn" data-theme="dark">深色</button>
        <button class="theme-btn" data-theme="pink">粉色</button>
        <button class="theme-btn" data-theme="green">绿色</button>
        <button class="theme-btn" id="config-btn-header" style="background-color: #f39c12;">⚙️</button>
        <button class="theme-btn" id="clear-cache-btn" style="background-color: #e74c3c;" title="清除映射缓存">🗑️</button>
    </div>

    <div class="container">
        <h1>喵语翻译器</h1>

        <div class="tabs">
            <div class="tab active" id="encrypt-tab">加密</div>
            <div class="tab" id="decrypt-tab">解密</div>
        </div>
        
        <div id="encrypt-panel">
            <textarea id="encrypt-input" placeholder="请输入要加密的文本..." maxlength="5000"></textarea>
            <div class="char-counter" id="encrypt-counter">0 / 5000 字符</div>
            <div class="length-warning" id="encrypt-warning">
                ⚠️ 文本较长，加密后的结果可能很大，建议分段处理或使用较短的文本。
            </div>
            <button id="encrypt-btn">加密</button>

            <div class="result result-container" id="encrypt-result" style="display: none;">
                <h3>加密结果：</h3>
                <div class="result-preview" id="encrypt-output"></div>
                <div class="result-actions">
                    <div class="result-stats" id="encrypt-stats"></div>
                    <button id="copy-encrypt" class="copy-btn">复制结果</button>
                    <button id="download-encrypt" class="copy-btn" style="background-color: #9b59b6;">下载文件</button>
                </div>
            </div>
        </div>

        <div id="decrypt-panel" style="display: none;">
            <textarea id="decrypt-input" placeholder="请输入要解密的文本..."></textarea>
            <div class="char-counter" id="decrypt-counter">0 字符</div>
            <div class="length-warning" id="decrypt-warning">
                ⚠️ 输入文本较长，解密可能需要一些时间，请耐心等待。
            </div>
            <button id="decrypt-btn">解密</button>

            <div class="result result-container" id="decrypt-result" style="display: none;">
                <h3>解密结果：</h3>
                <div class="result-preview" id="decrypt-output"></div>
                <div class="result-actions">
                    <div class="result-stats" id="decrypt-stats"></div>
                    <button id="copy-decrypt" class="copy-btn">复制结果</button>
                    <button id="download-decrypt" class="copy-btn" style="background-color: #9b59b6;">下载文件</button>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>喵语翻译器 &copy; 2025</p>
    </div>

    <!-- 配置对话框 -->
    <div id="config-modal" class="config-modal">
        <div class="config-modal-content">
            <span class="config-close">&times;</span>
            <h2>配置参数</h2>

            <div class="config-section">
                <h4>加密参数</h4>
                <label>版本号 (VERSION):</label>
                <input type="text" id="config-version" class="config-input" placeholder="例如: MiaoV0721">

                <label>密钥 (KEY):</label>
                <input type="text" id="config-key" class="config-input" placeholder="例如: 2hY8u5Pq3zRv7xW4jN0c1fT9eD6aXsB0">

                <label>盐值 (SALT):</label>
                <input type="text" id="config-salt" class="config-input" placeholder="例如: K7mLp2oQ9nRz8sV4tC1uJ6yF3dH5gXbE">
            </div>

            <div class="config-section">
                <h4>喵语词汇</h4>
                <label>喵语短语 (每行一个):</label>
                <textarea id="config-phrases" class="config-textarea" placeholder="喵&#10;喵喵&#10;喵~&#10;喵呜&#10;喵嗷&#10;喵喵喵"></textarea>
            </div>

            <div class="config-section">
                <h4>标点符号</h4>
                <label>标点符号 (每行一个):</label>
                <textarea id="config-punctuations" class="config-textarea" placeholder="，&#10;。&#10;！&#10;？&#10;~&#10;..."></textarea>
            </div>

            <div class="config-buttons">
                <button class="config-btn config-btn-danger" id="config-reset">重置为默认</button>
                <button class="config-btn config-btn-secondary" id="config-cancel">取消</button>
                <button class="config-btn config-btn-primary" id="config-save">保存配置</button>
            </div>
        </div>
    </div>

    <script>
        // 零宽字符集
        const ZERO_WIDTH_CHARS = [
            '\u200b',
            '\u200c',
            '\u200d',
            '\u2060',
            '\u200e',
            '\u200f',
            '\ufeff',
        ];

        // 默认配置
        const DEFAULT_CONFIG = {
            VERSION: "MiaoV0721",
            KEY: "2hY8u5Pq3zRv7xW4jN0c1fT9eD6aXsB0",
            SALT: "K7mLp2oQ9nRz8sV4tC1uJ6yF3dH5gXbE",
            PHRASES: ["喵", "喵喵", "喵~", "喵呜", "喵嗷", "喵喵喵"],
            PUNCTUATIONS: ["，", "。", "！", "？", "~", "..."],
            MAX_INPUT_LENGTH: 5000,  // 最大输入长度
            CHUNK_SIZE: 1000,        // 分块处理大小
            WARNING_LENGTH: 100,     // 降低警告长度阈值
            ULTRA_COMPACT_MODE: false // 禁用超紧凑模式，统一使用标准模式
        };

        // 当前配置（可以被用户修改）
        let CONFIG = { ...DEFAULT_CONFIG };

        // 为了向后兼容，保留原有的变量名
        let KEY = CONFIG.KEY;
        let SALT = CONFIG.SALT;
        let VERSION = CONFIG.VERSION;
        let PHRASES = [...CONFIG.PHRASES];
        let PUNCTUATIONS = [...CONFIG.PUNCTUATIONS];

        // 配置管理函数
        function loadConfig() {
            console.log('开始加载配置...');
            const savedConfig = localStorage.getItem('miao-config');
            console.log('从localStorage读取的配置:', savedConfig);
            if (savedConfig) {
                try {
                    const parsed = JSON.parse(savedConfig);
                    console.log('解析后的配置:', parsed);
                    CONFIG = { ...DEFAULT_CONFIG, ...parsed };
                    console.log('合并后的CONFIG:', CONFIG);
                    updateVariables();
                } catch (e) {
                    console.warn('配置加载失败，使用默认配置:', e);
                }
            } else {
                console.log('没有找到保存的配置，使用默认配置');
            }
        }

        function saveConfig() {
            localStorage.setItem('miao-config', JSON.stringify(CONFIG));
            updateVariables();
        }

        function updateVariables() {
            KEY = CONFIG.KEY;
            SALT = CONFIG.SALT;
            VERSION = CONFIG.VERSION;
            PHRASES = [...CONFIG.PHRASES];
            PUNCTUATIONS = [...CONFIG.PUNCTUATIONS];
            console.log('配置已更新:', { KEY, SALT, VERSION, PHRASES, PUNCTUATIONS });
        }

        function resetConfig() {
            CONFIG = { ...DEFAULT_CONFIG };
            updateVariables();
            updateConfigUI();
        }

        function updateConfigUI() {
            document.getElementById('config-version').value = CONFIG.VERSION;
            document.getElementById('config-key').value = CONFIG.KEY;
            document.getElementById('config-salt').value = CONFIG.SALT;
            document.getElementById('config-phrases').value = CONFIG.PHRASES.join('\n');
            document.getElementById('config-punctuations').value = CONFIG.PUNCTUATIONS.join('\n');
        }

        function getConfigFromUI() {
            const phrases = document.getElementById('config-phrases').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            const punctuations = document.getElementById('config-punctuations').value
                .split('\n')
                .map(p => p.trim())
                .filter(p => p.length > 0);

            return {
                VERSION: document.getElementById('config-version').value.trim() || DEFAULT_CONFIG.VERSION,
                KEY: document.getElementById('config-key').value.trim() || DEFAULT_CONFIG.KEY,
                SALT: document.getElementById('config-salt').value.trim() || DEFAULT_CONFIG.SALT,
                PHRASES: phrases.length > 0 ? phrases : DEFAULT_CONFIG.PHRASES,
                PUNCTUATIONS: punctuations.length > 0 ? punctuations : DEFAULT_CONFIG.PUNCTUATIONS
            };
        }

        // 全局映射表缓存，确保加密和解密使用相同的映射
        let GLOBAL_MAPPING_CACHE = null;

        // 清除映射缓存的函数（用于调试）
        function clearMappingCache() {
            GLOBAL_MAPPING_CACHE = null;
            console.log('映射缓存已清除');
        }

        // 测试映射正确性的函数
        function testMapping() {
            console.log('=== 开始映射测试 ===');

            // 创建映射
            const mapping = createBase64ToZeroWidthMap();

            // 创建反向映射
            const reverseMapping = {};
            for (const [key, value] of Object.entries(mapping)) {
                reverseMapping[value] = key;
            }

            console.log(`正向映射数量: ${Object.keys(mapping).length}`);
            console.log(`反向映射数量: ${Object.keys(reverseMapping).length}`);

            // 测试前10个字符的往返转换
            const testChars = "ABCDEFGHIJabcdefghij";
            let allPassed = true;

            for (let i = 0; i < testChars.length; i++) {
                const char = testChars[i];
                const zwCombo = mapping[char];
                const backToChar = reverseMapping[zwCombo];

                const passed = char === backToChar;
                if (!passed) allPassed = false;

                const comboDebug = Array.from(zwCombo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');
                console.log(`测试 "${char}": ${char} -> ${comboDebug} -> "${backToChar}" ${passed ? '✓' : '✗'}`);
            }

            console.log(`=== 映射测试结果: ${allPassed ? '全部通过' : '存在问题'} ===`);
            return allPassed;
        }

        // 测试完整加密解密流程的函数
        function testFullEncryptDecrypt() {
            console.log('=== 开始完整加密解密测试 ===');

            const testMessage = "测试";
            console.log(`测试消息: "${testMessage}"`);

            try {
                // 加密
                const encrypted = encryptMessage(testMessage);
                console.log(`加密结果长度: ${encrypted.length}`);

                // 提取零宽字符
                const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                const encryptedZwChars = encrypted.match(zeroWidthCharsRegex) || [];
                console.log(`加密时生成的零宽字符数量: ${encryptedZwChars.length}`);
                console.log(`前9个加密零宽字符:`);
                for (let i = 0; i < Math.min(9, encryptedZwChars.length); i++) {
                    const char = encryptedZwChars[i];
                    const code = char.charCodeAt(0).toString(16).padStart(4, '0');
                    console.log(`  [${i}] \\u${code}`);
                }

                // 解密
                const decrypted = decryptMessage(encrypted);
                console.log(`解密结果: "${decrypted}"`);

                const success = testMessage === decrypted;
                console.log(`=== 完整测试结果: ${success ? '✅ 成功' : '❌ 失败'} ===`);
                return success;
            } catch (e) {
                console.error(`测试过程中出错: ${e.message}`);
                return false;
            }
        }

        // 使用3个零宽字符组合的Base64映射，确保足够的唯一组合
        function createBase64ToZeroWidthMap() {
            // 如果已有缓存，直接返回
            if (GLOBAL_MAPPING_CACHE) {
                console.log(`使用缓存的映射表: ${Object.keys(GLOBAL_MAPPING_CACHE).length} 个映射`);
                return GLOBAL_MAPPING_CACHE;
            }

            const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            const mapping = {};

            // 使用3个零宽字符的组合：7^3 = 343 种组合，远超65个Base64字符的需求
            const zwChars = ZERO_WIDTH_CHARS;
            const totalCombinations = zwChars.length * zwChars.length * zwChars.length;

            console.log(`创建新映射: ${base64Chars.length} 个Base64字符, ${zwChars.length} 个零宽字符, ${totalCombinations} 种可能组合`);
            console.log(`零宽字符列表:`, zwChars.map((c, i) => `[${i}] \\u${c.charCodeAt(0).toString(16).padStart(4, '0')}`));

            for (let i = 0; i < base64Chars.length; i++) {
                const char = base64Chars[i];

                // 使用更均匀的三位数系统分配零宽字符组合
                // 确保每个位置都能充分利用
                const firstIndex = i % zwChars.length;
                const secondIndex = Math.floor(i / zwChars.length) % zwChars.length;
                const thirdIndex = Math.floor(i / (zwChars.length * zwChars.length)) % zwChars.length;

                const zeroWidthCombo = zwChars[firstIndex] + zwChars[secondIndex] + zwChars[thirdIndex];
                mapping[char] = zeroWidthCombo;

                if (i < 15) {
                    const comboDebug = Array.from(zeroWidthCombo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');
                    console.log(`[${i}] "${char}" -> [${firstIndex},${secondIndex},${thirdIndex}] -> ${comboDebug}`);
                }
            }

            // 验证映射的唯一性
            const reverseMapping = {};
            let conflicts = 0;

            for (const [char, combo] of Object.entries(mapping)) {
                if (reverseMapping[combo]) {
                    conflicts++;
                    console.error(`映射冲突: "${char}" 和 "${reverseMapping[combo]}" 都映射到相同组合`);
                } else {
                    reverseMapping[combo] = char;
                }
            }

            if (conflicts > 0) {
                throw new Error(`映射表存在 ${conflicts} 个冲突`);
            }

            console.log(`映射创建成功: ${Object.keys(mapping).length} 个映射，无冲突`);

            // 测试前几个映射的反向查找
            console.log(`测试反向映射:`);
            for (let i = 0; i < Math.min(5, base64Chars.length); i++) {
                const char = base64Chars[i];
                const combo = mapping[char];
                const reverseChar = reverseMapping[combo];
                console.log(`  "${char}" -> ${Array.from(combo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('')} -> "${reverseChar}" ${char === reverseChar ? '✓' : '✗'}`);
            }

            // 缓存映射表
            GLOBAL_MAPPING_CACHE = mapping;
            return mapping;
        }

        // 混淆函数
        function starResonanceScramble(str, key, salt) {
            try {
                // 1. 将输入字符串与盐值组合
                const saltedInput = str + ":" + salt;
                
                // 2. 使用密钥的特征值进行额外处理
                let result = '';
                const keyChars = Array.from(key);
                const keySum = keyChars.reduce((sum, char) => sum + char.charCodeAt(0), 0);
                
                for (let i = 0; i < saltedInput.length; i++) {
                    const charCode = saltedInput.charCodeAt(i);
                    const keyChar = key.charCodeAt(i % key.length);
                    const xorResult = charCode ^ keyChar;
                    
                    // 根据位置和密钥特征值进行偏移
                    const offset = (i % 3 === 0) ? (keySum % 7) : ((i % 3 === 1) ? -(keySum % 5) : (keySum % 3));
                    const finalCharCode = (xorResult + offset + 65536) % 65536; // 确保在有效Unicode范围内
                    
                    result += String.fromCharCode(finalCharCode);
                }
                
                // 3. 添加版本标记
                return VERSION + ":" + result;
            } catch (e) {
                console.error("混淆过程中出错:", e);
                throw e;
            }
        }

        // 解混淆函数
        function starResonanceUnscramble(scrambled, key, salt) {
            try {
                // 1. 验证并移除版本标记
                if (!scrambled.startsWith(VERSION + ":")) {
                    console.error("版本标记不匹配:", scrambled.substring(0, 20));
                    throw new Error("无效的加密格式或版本不匹配");
                }
                
                const dataWithoutVersion = scrambled.substring(VERSION.length + 1);
                
                // 2. 反向应用额外处理
                let result = '';
                const keyChars = Array.from(key);
                const keySum = keyChars.reduce((sum, char) => sum + char.charCodeAt(0), 0);
                
                for (let i = 0; i < dataWithoutVersion.length; i++) {
                    // 反向应用额外处理
                    const charCode = dataWithoutVersion.charCodeAt(i);
                    const offset = (i % 3 === 0) ? (keySum % 7) : ((i % 3 === 1) ? -(keySum % 5) : (keySum % 3));
                    const unshiftedCharCode = (charCode - offset + 65536) % 65536; // 确保在有效Unicode范围内
                    
                    // XOR解密
                    const keyChar = key.charCodeAt(i % key.length);
                    const originalCharCode = unshiftedCharCode ^ keyChar;
                    
                    result += String.fromCharCode(originalCharCode);
                }
                
                // 3. 移除盐值 - 改进版本，更好地处理边界情况
                const saltMarker = ":" + salt;
                const saltIndex = result.lastIndexOf(saltMarker);

                if (saltIndex === -1) {
                    console.error("无法找到完整的盐值标记，尝试其他方法");
                    console.log("解混淆结果:", result);
                    console.log("期望的盐值标记:", saltMarker);

                    // 尝试查找任何冒号分隔符
                    const lastColonIndex = result.lastIndexOf(":");
                    if (lastColonIndex !== -1) {
                        const possibleSalt = result.substring(lastColonIndex + 1);
                        console.log("找到的可能盐值:", possibleSalt);

                        // 检查是否是预期的盐值
                        if (possibleSalt === salt) {
                            console.log("找到匹配的盐值，使用冒号分隔点");
                            return result.substring(0, lastColonIndex);
                        } else {
                            console.log("盐值不匹配，尝试直接返回结果");
                            // 如果盐值不匹配，可能是解混淆过程中的字符编码问题
                            // 尝试返回去掉最后部分的结果
                            return result.substring(0, lastColonIndex);
                        }
                    }

                    // 最后的备用方案：检查结果是否已经是有效的原始消息
                    console.log("无法找到盐值分隔符，检查结果是否有效");
                    if (result.length > salt.length + 1) {
                        // 尝试去掉可能的盐值后缀
                        const withoutSuffix = result.substring(0, result.length - salt.length - 1);
                        console.log("尝试去掉后缀:", withoutSuffix);
                        return withoutSuffix;
                    }

                    throw new Error("解密失败：无效的数据格式");
                }

                return result.substring(0, saltIndex);
            } catch (e) {
                console.error("解混淆过程中出错:", e);
                throw e;
            }
        }

        // 统一的加密消息函数
        function encryptMessage(message) {
            try {
                console.log(`开始加密消息: "${message}"`);

                // 1. 简单的字符编码，不使用复杂的混淆
                const encoded = btoa(unescape(encodeURIComponent(message + ":" + VERSION)));
                console.log(`Base64编码: "${encoded}" (长度: ${encoded.length})`);

                // 2. 创建Base64到零宽字符的映射
                const b64ToZwMap = createBase64ToZeroWidthMap();

                // 3. 将Base64转为零宽字符
                let zeroWidthMessage = "";
                for (let i = 0; i < encoded.length; i++) {
                    const b64Char = encoded[i];
                    const zwCombo = b64ToZwMap[b64Char];
                    if (!zwCombo) {
                        console.error(`Base64字符 '${b64Char}' 没有对应的零宽字符映射`);
                        throw new Error(`映射错误: 字符 '${b64Char}' 未找到映射`);
                    }
                    zeroWidthMessage += zwCombo;
                }
                console.log(`零宽字符消息长度: ${zeroWidthMessage.length}`);

                // 4. 生成喵语文本
                const result = generateSimpleMeowText(zeroWidthMessage, message.length);
                console.log(`最终加密结果长度: ${result.length}`);
                return result;
            } catch (e) {
                console.error("加密过程中出错:", e);
                throw new Error(`加密失败: ${e.message}`);
            }
        }



        // 喵语文本生成函数
        function generateSimpleMeowText(zeroWidthMessage, originalLength) {
            // 确保短密文也有足够的可见字符
            const result = generateVisibleTextForShortMessage(zeroWidthMessage, originalLength);

            return result + zeroWidthMessage;
        }

        // 为短消息生成足够的可见字符
        function generateVisibleTextForShortMessage(zeroWidthMessage, originalLength) {
            const zwLength = zeroWidthMessage.length;
            let result = "";

            // 计算需要的可见字符数量
            // 对于短消息，确保至少有3-5个可见字符
            let minVisibleChars = Math.max(3, Math.min(5, Math.ceil(originalLength / 3)));

            // 如果零宽字符很少，增加可见字符数量以保持平衡
            if (zwLength < 20) {
                minVisibleChars = Math.max(minVisibleChars, 4);
            }

            // 添加多样化的喵语词汇
            for (let i = 0; i < minVisibleChars; i++) {
                if (i === 0) {
                    // 开头总是用最短的"喵"
                    result += PHRASES[0];
                } else {
                    // 后续使用不同的喵语词汇和标点
                    if (i % 2 === 1 && PHRASES.length > 1) {
                        // 奇数位置使用其他喵语词汇
                        const phraseIndex = (i - 1) % (PHRASES.length - 1) + 1;
                        result += PHRASES[phraseIndex];
                    } else {
                        // 偶数位置使用标点符号
                        const punctIndex = Math.floor((i - 2) / 2) % PUNCTUATIONS.length;
                        result += PUNCTUATIONS[punctIndex];
                    }
                }
            }

            return result;
        }

        // 分块处理大文本
        function processLargeText(text, operation) {
            const chunkSize = CONFIG.CHUNK_SIZE || 1000;
            if (text.length <= chunkSize) {
                return operation(text);
            }

            const chunks = [];
            for (let i = 0; i < text.length; i += chunkSize) {
                chunks.push(text.substring(i, i + chunkSize));
            }

            console.log(`分块处理: ${chunks.length} 个块，每块最大 ${chunkSize} 字符`);

            const results = chunks.map((chunk, index) => {
                console.log(`处理第 ${index + 1}/${chunks.length} 块`);
                return operation(chunk);
            });

            return results.join('');
        }

        // 检查文本长度并显示警告
        function checkTextLength(text, warningElement, counterElement, maxLength) {
            const length = text.length;
            const warningThreshold = CONFIG.WARNING_LENGTH || 1000;

            if (counterElement) {
                if (maxLength) {
                    counterElement.textContent = `${length} / ${maxLength} 字符`;
                    counterElement.className = 'char-counter';
                    if (length > maxLength * 0.8) {
                        counterElement.className += ' warning';
                    }
                    if (length > maxLength * 0.95) {
                        counterElement.className += ' danger';
                    }
                } else {
                    counterElement.textContent = `${length} 字符`;
                }
            }

            if (warningElement) {
                if (length > warningThreshold) {
                    warningElement.style.display = 'block';
                } else {
                    warningElement.style.display = 'none';
                }
            }

            return length <= (maxLength || Infinity);
        }

        // 统一的解密消息函数
        function decryptMessage(encryptedMessage) {
            try {
                console.log(`开始解密消息，长度: ${encryptedMessage.length}`);

                // 1. 创建Base64到零宽字符的映射
                const b64ToZwMap = createBase64ToZeroWidthMap();

                // 创建反向映射
                const zwToB64Map = {};
                for (const [key, value] of Object.entries(b64ToZwMap)) {
                    zwToB64Map[value] = key;
                }

                console.log(`反向映射创建完成: ${Object.keys(zwToB64Map).length} 个映射`);

                // 测试前几个反向映射
                console.log(`测试反向映射:`);
                const testKeys = Object.keys(zwToB64Map).slice(0, 3);
                for (const combo of testKeys) {
                    const char = zwToB64Map[combo];
                    const comboDebug = Array.from(combo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');
                    console.log(`  ${comboDebug} -> "${char}"`);
                }

                // 2. 提取所有零宽字符
                const zeroWidthCharsRegex = new RegExp(`[${ZERO_WIDTH_CHARS.join('')}]`, 'g');
                const zeroWidthMatches = encryptedMessage.match(zeroWidthCharsRegex) || [];
                const zeroWidthOnly = zeroWidthMatches.join('');

                console.log(`提取到 ${zeroWidthOnly.length} 个零宽字符`);

                // 分析前几个零宽字符
                console.log(`前几个零宽字符分析:`);
                for (let i = 0; i < Math.min(9, zeroWidthOnly.length); i++) {
                    const char = zeroWidthOnly[i];
                    const code = char.charCodeAt(0).toString(16).padStart(4, '0');
                    console.log(`  [${i}] \\u${code}`);
                }

                // 3. 将零宽字符转回Base64
                let base64Message = "";
                const COMBO_LENGTH = 3; // 3个零宽字符的组合
                let unmappedCount = 0;

                for (let i = 0; i < zeroWidthOnly.length; i += COMBO_LENGTH) {
                    if (i + COMBO_LENGTH <= zeroWidthOnly.length) {
                        const zwCombo = zeroWidthOnly.substring(i, i + COMBO_LENGTH);
                        const comboDebug = Array.from(zwCombo).map(c => '\\u' + c.charCodeAt(0).toString(16).padStart(4, '0')).join('');

                        if (zwCombo in zwToB64Map) {
                            const mappedChar = zwToB64Map[zwCombo];
                            base64Message += mappedChar;

                            if (Math.floor(i / COMBO_LENGTH) < 3) {
                                console.log(`[${Math.floor(i/COMBO_LENGTH)}] ${comboDebug} -> "${mappedChar}" ✓`);
                            }
                        } else {
                            unmappedCount++;
                            if (unmappedCount <= 3) {
                                console.warn(`[${Math.floor(i/COMBO_LENGTH)}] ${comboDebug} -> 未找到映射 ✗`);
                            }
                            base64Message += 'A'; // 默认字符
                        }
                    }
                }

                console.log(`映射结果: 成功 ${Math.floor(zeroWidthOnly.length / COMBO_LENGTH) - unmappedCount}, 失败 ${unmappedCount}`);

                // 4. 修复Base64填充
                base64Message = fixBase64Padding(base64Message);

                // 5. 验证Base64有效性
                if (!isValidBase64(base64Message)) {
                    console.error("Base64字符串无效:", base64Message);
                    throw new Error("解密失败：无效的Base64格式");
                }

                // 6. 解码Base64
                let decoded;
                try {
                    decoded = atob(base64Message);
                    decoded = decodeURIComponent(escape(decoded));
                } catch (e) {
                    console.error("Base64解码失败:", e);
                    throw new Error("解密失败：Base64解码错误");
                }

                // 7. 移除版本标记
                const versionMarker = ":" + VERSION;
                const versionIndex = decoded.lastIndexOf(versionMarker);
                if (versionIndex !== -1) {
                    return decoded.substring(0, versionIndex);
                }

                console.log("未找到版本标记，直接返回解码结果");
                return decoded;
            } catch (e) {
                console.error("解密错误详情:", e);
                throw new Error(`解密失败: ${e.message}`);
            }
        }



        // 修复Base64填充的辅助函数
        function fixBase64Padding(str) {
            // 移除所有现有的填充字符
            str = str.replace(/=+$/, '');

            // 根据长度添加正确的填充
            const remainder = str.length % 4;
            if (remainder === 2) {
                str += '==';
            } else if (remainder === 3) {
                str += '=';
            }
            // remainder === 0 或 1 时不需要填充（1是无效的，但我们先尝试处理）

            return str;
        }

        // 添加辅助函数检查Base64有效性 - 改进版本
        function isValidBase64(str) {
            try {
                // 检查基本格式
                if (!str) {
                    return false;
                }

                // 检查字符是否都是有效的Base64字符
                const validChars = /^[A-Za-z0-9+/=]+$/;
                if (!validChars.test(str)) {
                    return false;
                }

                // 检查长度是否为4的倍数
                if (str.length % 4 !== 0) {
                    return false;
                }

                // 检查填充字符的位置是否正确
                const paddingMatch = str.match(/=*$/);
                if (paddingMatch) {
                    const paddingLength = paddingMatch[0].length;
                    if (paddingLength > 2) {
                        return false; // 填充字符不能超过2个
                    }

                    // 检查填充前的字符是否有效
                    const withoutPadding = str.substring(0, str.length - paddingLength);
                    if (paddingLength > 0 && withoutPadding.length % 4 !== (4 - paddingLength) % 4) {
                        return false;
                    }
                }

                // 尝试解码
                atob(str);
                return true;
            } catch (e) {
                return false;
            }
        }

        // 清除缓存按钮事件监听器
        document.getElementById('clear-cache-btn').addEventListener('click', function() {
            clearMappingCache();
            alert('映射缓存已清除！下次加密/解密时将重新创建映射表。');
        });

        // 主题切换功能
        document.querySelectorAll('.theme-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                // 如果是配置按钮或清除缓存按钮，不处理主题切换
                if (this.id === 'config-btn-header' || this.id === 'clear-cache-btn') {
                    return;
                }

                const theme = this.getAttribute('data-theme');

                // 移除所有主题类
                document.body.classList.remove('dark-theme', 'pink-theme', 'green-theme');

                // 添加新主题类
                if (theme !== 'default') {
                    document.body.classList.add(theme + '-theme');
                }

                // 更新按钮状态（排除配置按钮和清除缓存按钮）
                document.querySelectorAll('.theme-btn').forEach(b => {
                    if (b.id !== 'config-btn-header' && b.id !== 'clear-cache-btn') {
                        b.classList.remove('active');
                    }
                });
                this.classList.add('active');

                // 保存主题设置
                localStorage.setItem('theme', theme);
            });
        });

        // 加载保存的主题
        const savedTheme = localStorage.getItem('theme') || 'default';
        if (savedTheme !== 'default') {
            document.body.classList.add(savedTheme + '-theme');
        }

        // 设置主题按钮状态（排除配置按钮和清除缓存按钮）
        document.querySelectorAll('.theme-btn').forEach(b => {
            if (b.id !== 'config-btn-header' && b.id !== 'clear-cache-btn') {
                if (b.getAttribute('data-theme') === savedTheme) {
                    b.classList.add('active');
                } else {
                    b.classList.remove('active');
                }
            }
        });

        // 确保DOM完全加载后再加载配置和初始化调试面板
        document.addEventListener('DOMContentLoaded', function() {
            clearMappingCache(); // 清除映射缓存，确保使用最新的映射算法
            loadConfig();
            initializeDebugPanel();
        });

        // 配置对话框事件监听器
        const configModal = document.getElementById('config-modal');
        const configBtnHeader = document.getElementById('config-btn-header');
        const configClose = document.querySelector('.config-close');
        const configSave = document.getElementById('config-save');
        const configCancel = document.getElementById('config-cancel');
        const configReset = document.getElementById('config-reset');

        // 打开配置对话框
        configBtnHeader.addEventListener('click', function() {
            updateConfigUI();
            configModal.style.display = 'block';
        });

        // 关闭配置对话框
        configClose.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        configCancel.addEventListener('click', function() {
            configModal.style.display = 'none';
        });

        // 点击对话框外部关闭
        window.addEventListener('click', function(event) {
            if (event.target === configModal) {
                configModal.style.display = 'none';
            }
        });

        // 保存配置
        configSave.addEventListener('click', function() {
            console.log('保存配置前:', CONFIG);
            const newConfig = getConfigFromUI();
            console.log('从UI获取的新配置:', newConfig);
            CONFIG = newConfig;
            console.log('更新后的CONFIG:', CONFIG);
            saveConfig();
            configModal.style.display = 'none';
            alert('配置已保存！');
        });

        // 重置配置
        configReset.addEventListener('click', function() {
            if (confirm('确定要重置为默认配置吗？这将清除所有自定义设置。')) {
                resetConfig();
                alert('配置已重置为默认值！');
            }
        });

        // 切换标签页
        document.getElementById('encrypt-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('decrypt-tab').classList.remove('active');
            document.getElementById('encrypt-panel').style.display = 'block';
            document.getElementById('decrypt-panel').style.display = 'none';
        });

        document.getElementById('decrypt-tab').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('encrypt-tab').classList.remove('active');
            document.getElementById('decrypt-panel').style.display = 'block';
            document.getElementById('encrypt-panel').style.display = 'none';
        });

        // 文件下载功能
        function downloadText(text, filename) {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 加密按钮点击事件 - 优化版本
        document.getElementById('encrypt-btn').addEventListener('click', function() {
            const input = document.getElementById('encrypt-input').value;
            if (!input) {
                alert('请输入要加密的文本');
                return;
            }

            // 检查文本长度
            if (input.length > CONFIG.MAX_INPUT_LENGTH) {
                alert(`文本长度超过限制（${CONFIG.MAX_INPUT_LENGTH} 字符），请缩短文本或分段处理`);
                return;
            }

            // 显示处理状态
            const btn = this;
            const originalText = btn.textContent;
            btn.textContent = '加密中...';
            btn.disabled = true;

            // 使用 setTimeout 让UI有时间更新
            setTimeout(() => {
                try {
                    const startTime = performance.now();
                    let encrypted;

                    if (input.length > CONFIG.CHUNK_SIZE) {
                        encrypted = processLargeText(input, encryptMessage);
                    } else {
                        encrypted = encryptMessage(input);
                    }

                    const endTime = performance.now();
                    const processingTime = (endTime - startTime).toFixed(2);

                    // 显示结果
                    const outputElement = document.getElementById('encrypt-output');
                    const statsElement = document.getElementById('encrypt-stats');

                    // 限制显示长度，避免页面卡顿
                    const maxDisplayLength = 1000;
                    if (encrypted.length > maxDisplayLength) {
                        outputElement.textContent = encrypted.substring(0, maxDisplayLength) + '\n\n... (结果过长，已截断显示，请使用复制或下载功能获取完整结果)';
                    } else {
                        outputElement.textContent = encrypted;
                    }

                    // 显示统计信息
                    const compressionRatio = (encrypted.length / input.length).toFixed(2);
                    const fileSize = formatFileSize(new Blob([encrypted]).size);
                    statsElement.textContent = `长度: ${encrypted.length} 字符 | 压缩比: ${compressionRatio}:1 | 大小: ${fileSize} | 耗时: ${processingTime}ms`;

                    document.getElementById('encrypt-result').style.display = 'block';

                    // 存储完整结果用于复制和下载
                    window.lastEncryptResult = encrypted;

                } catch (e) {
                    alert(`加密失败: ${e.message}`);
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }, 10);
        });

        // 解密按钮点击事件 - 优化版本
        document.getElementById('decrypt-btn').addEventListener('click', function() {
            const input = document.getElementById('decrypt-input').value;
            if (!input) {
                alert('请输入要解密的文本');
                return;
            }

            // 显示处理状态
            const btn = this;
            const originalText = btn.textContent;
            btn.textContent = '解密中...';
            btn.disabled = true;

            // 使用 setTimeout 让UI有时间更新
            setTimeout(() => {
                try {
                    const startTime = performance.now();
                    const decrypted = decryptMessage(input);
                    const endTime = performance.now();
                    const processingTime = (endTime - startTime).toFixed(2);

                    // 显示结果
                    const outputElement = document.getElementById('decrypt-output');
                    const statsElement = document.getElementById('decrypt-stats');

                    // 限制显示长度，避免页面卡顿
                    const maxDisplayLength = 1000;
                    if (decrypted.length > maxDisplayLength) {
                        outputElement.textContent = decrypted.substring(0, maxDisplayLength) + '\n\n... (结果过长，已截断显示，请使用复制或下载功能获取完整结果)';
                    } else {
                        outputElement.textContent = decrypted;
                    }

                    // 显示统计信息
                    const fileSize = formatFileSize(new Blob([decrypted]).size);
                    statsElement.textContent = `长度: ${decrypted.length} 字符 | 大小: ${fileSize} | 耗时: ${processingTime}ms`;

                    document.getElementById('decrypt-result').style.display = 'block';

                    // 存储完整结果用于复制和下载
                    window.lastDecryptResult = decrypted;

                } catch (e) {
                    alert(`解密失败: ${e.message}`);
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }, 10);
        });

        // 复制加密结果 - 使用完整结果
        document.getElementById('copy-encrypt').addEventListener('click', function() {
            const text = window.lastEncryptResult || document.getElementById('encrypt-output').textContent;
            navigator.clipboard.writeText(text).then(function() {
                alert('已复制到剪贴板');
            }, function() {
                alert('复制失败，请手动复制');
            });
        });

        // 复制解密结果 - 使用完整结果
        document.getElementById('copy-decrypt').addEventListener('click', function() {
            const text = window.lastDecryptResult || document.getElementById('decrypt-output').textContent;
            navigator.clipboard.writeText(text).then(function() {
                alert('已复制到剪贴板');
            }, function() {
                alert('复制失败，请手动复制');
            });
        });

        // 下载加密结果
        document.getElementById('download-encrypt').addEventListener('click', function() {
            const text = window.lastEncryptResult || document.getElementById('encrypt-output').textContent;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            downloadText(text, `encrypted_${timestamp}.txt`);
        });

        // 下载解密结果
        document.getElementById('download-decrypt').addEventListener('click', function() {
            const text = window.lastDecryptResult || document.getElementById('decrypt-output').textContent;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            downloadText(text, `decrypted_${timestamp}.txt`);
        });

        // 输入框字符计数和警告
        document.getElementById('encrypt-input').addEventListener('input', function() {
            checkTextLength(
                this.value,
                document.getElementById('encrypt-warning'),
                document.getElementById('encrypt-counter'),
                CONFIG.MAX_INPUT_LENGTH
            );
        });

        document.getElementById('decrypt-input').addEventListener('input', function() {
            checkTextLength(
                this.value,
                document.getElementById('decrypt-warning'),
                document.getElementById('decrypt-counter')
            );
        });

        // 初始化调试面板
        function initializeDebugPanel() {
            // 添加调试按钮和面板
            const container = document.querySelector('.container');
            if (container && !document.getElementById('debug-btn')) {
                container.insertAdjacentHTML('beforeend', `
                    <div class="debug-panel">
                        <h3>调试工具</h3>
                        <div class="debug-controls">
                            <button id="debug-btn">系统调试</button>
                            <button id="test-mapping-btn">映射测试</button>
                            <button id="test-full-btn">完整测试</button>
                            <button id="clear-debug-btn">清除结果</button>
                        </div>

                        <div id="debug-results" style="margin-top: 15px;">
                            <div id="system-debug" class="debug-section" style="display: none;">
                                <h4>系统调试信息</h4>
                                <pre id="system-debug-content"></pre>
                            </div>

                            <div id="mapping-test" class="debug-section" style="display: none;">
                                <h4>映射测试结果</h4>
                                <div id="mapping-test-status"></div>
                                <pre id="mapping-test-content"></pre>
                            </div>

                            <div id="full-test" class="debug-section" style="display: none;">
                                <h4>完整加密解密测试</h4>
                                <div id="full-test-status"></div>
                                <pre id="full-test-content"></pre>
                            </div>
                        </div>
                    </div>
                `);

                // 清除调试结果按钮
                document.getElementById('clear-debug-btn').addEventListener('click', function() {
                    document.getElementById('system-debug').style.display = 'none';
                    document.getElementById('mapping-test').style.display = 'none';
                    document.getElementById('full-test').style.display = 'none';
                });

                // 测试映射按钮点击事件
                document.getElementById('test-mapping-btn').addEventListener('click', function() {
                    const section = document.getElementById('mapping-test');
                    const status = document.getElementById('mapping-test-status');
                    const content = document.getElementById('mapping-test-content');

                    section.style.display = 'block';
                    status.innerHTML = '正在测试...';
                    content.textContent = '';

                    // 重定向console.log到调试面板
                    const originalLog = console.log;
                    const logs = [];
                    console.log = function(...args) {
                        logs.push(args.join(' '));
                        originalLog.apply(console, args);
                    };

                    try {
                        const result = testMapping();
                        status.innerHTML = `<span class="${result ? 'status-success' : 'status-error'}">${result ? '✅ 测试通过' : '❌ 测试失败'}</span>`;
                        content.textContent = logs.join('\n');
                    } catch (e) {
                        status.innerHTML = `<span class="status-error">❌ 测试出错: ${e.message}</span>`;
                    } finally {
                        console.log = originalLog;
                    }
                });

                // 完整测试按钮点击事件
                document.getElementById('test-full-btn').addEventListener('click', function() {
                    const section = document.getElementById('full-test');
                    const status = document.getElementById('full-test-status');
                    const content = document.getElementById('full-test-content');

                    section.style.display = 'block';
                    status.innerHTML = '正在测试...';
                    content.textContent = '';

                    // 重定向console.log到调试面板
                    const originalLog = console.log;
                    const originalError = console.error;
                    const logs = [];
                    console.log = function(...args) {
                        logs.push(args.join(' '));
                        originalLog.apply(console, args);
                    };
                    console.error = function(...args) {
                        logs.push('ERROR: ' + args.join(' '));
                        originalError.apply(console, args);
                    };

                    try {
                        const result = testFullEncryptDecrypt();
                        status.innerHTML = `<span class="${result ? 'status-success' : 'status-error'}">${result ? '✅ 测试通过' : '❌ 测试失败'}</span>`;
                        content.textContent = logs.join('\n');
                    } catch (e) {
                        status.innerHTML = `<span class="status-error">❌ 测试出错: ${e.message}</span>`;
                    } finally {
                        console.log = originalLog;
                        console.error = originalError;
                    }
                });

                // 系统调试按钮点击事件
                document.getElementById('debug-btn').addEventListener('click', async function() {
                    const section = document.getElementById('system-debug');
                    const content = document.getElementById('system-debug-content');

                    section.style.display = 'block';
                    // 收集系统调试信息
                    let info = "";

                    // 1. 显示关键参数
                    info += "=== 系统配置 ===\n";
                    info += `VERSION: ${CONFIG.VERSION}\n`;
                    info += `KEY: ${CONFIG.KEY.substring(0, 10)}...\n`;
                    info += `SALT: ${CONFIG.SALT.substring(0, 10)}...\n`;
                    info += `PHRASES: [${CONFIG.PHRASES.join(', ')}]\n`;
                    info += `PUNCTUATIONS: [${CONFIG.PUNCTUATIONS.join(', ')}]\n\n`;

                    // 2. 零宽字符信息
                    info += "=== 零宽字符配置 ===\n";
                    info += `零宽字符数量: ${ZERO_WIDTH_CHARS.length}\n`;
                    info += `零宽字符列表:\n`;
                    ZERO_WIDTH_CHARS.forEach((char, index) => {
                        const code = char.charCodeAt(0).toString(16).padStart(4, '0');
                        info += `  [${index}] \\u${code}\n`;
                    });
                    info += `\n`;

                    // 3. 映射表状态
                    info += "=== 映射表状态 ===\n";
                    info += `映射缓存状态: ${GLOBAL_MAPPING_CACHE ? '已缓存' : '未缓存'}\n`;
                    if (GLOBAL_MAPPING_CACHE) {
                        info += `映射数量: ${Object.keys(GLOBAL_MAPPING_CACHE).length}\n`;
                    }

                    content.textContent = info;
                });
            }
        }
    </script>
</body>
</html>